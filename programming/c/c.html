<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-05-03 Sun 21:37 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Mike Chyson" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgad5a2ac">1. A Tutorial Instroduction</a>
<ul>
<li><a href="#org11ea7bf">1.1. Getting Started</a></li>
<li><a href="#orgfa02ff1">1.2. Variables and Arithmetic Expressions</a></li>
<li><a href="#orge74fc78">1.3. The for statement</a></li>
<li><a href="#org933e1a0">1.4. Symbolic Constants</a></li>
<li><a href="#org8e6fc49">1.5. Character Input and Output</a>
<ul>
<li><a href="#orgd850ff8">1.5.1. File Copying</a></li>
<li><a href="#org123922f">1.5.2. Character Counting</a></li>
<li><a href="#orge977704">1.5.3. Line Counting</a></li>
<li><a href="#org1eb35b0">1.5.4. Word Counting</a></li>
</ul>
</li>
<li><a href="#org8059e6e">1.6. Arrays</a></li>
<li><a href="#orgaea67e7">1.7. Functions</a></li>
<li><a href="#orgdaf9589">1.8. Arguments - Call by Value</a></li>
<li><a href="#org0a02a84">1.9. Character Arrays</a></li>
<li><a href="#org7f8e2ef">1.10. External Variables and Scope</a></li>
</ul>
</li>
<li><a href="#org4c903dd">2. Types, Operators and Expressions</a>
<ul>
<li><a href="#org206f4f2">2.1. Variable Names</a></li>
<li><a href="#org5f415be">2.2. Data Types and Sizes</a></li>
<li><a href="#orgb7be120">2.3. Constants</a></li>
<li><a href="#org7cbdbc6">2.4. Declarations</a></li>
<li><a href="#org4bafe2b">2.5. Arithmetic Operators</a></li>
<li><a href="#org6435edd">2.6. Relational and Logical Operators</a></li>
<li><a href="#org9c63a16">2.7. Type Conversions</a></li>
<li><a href="#org76d25e5">2.8. Increment and Decrement Operators</a></li>
<li><a href="#orgce89958">2.9. Bitwise Operators</a></li>
<li><a href="#org7c89ff3">2.10. Assignment Operators and Exmpressions</a></li>
<li><a href="#orga77ebb7">2.11. Conditional Expressions</a></li>
<li><a href="#org65c4a1a">2.12. Precedence and Order of Evaluation</a></li>
</ul>
</li>
<li><a href="#org1afdd09">3. Control Flow</a>
<ul>
<li><a href="#orga0beb32">3.1. Statements and Blocks</a></li>
<li><a href="#org63f3afc">3.2. If-Else</a></li>
<li><a href="#orgcbea9da">3.3. Else-If</a></li>
<li><a href="#org6648661">3.4. Switch</a></li>
<li><a href="#org0919cef">3.5. Loops - While and For</a></li>
<li><a href="#org95a7ee8">3.6. Loops - Do-While</a></li>
<li><a href="#org322e207">3.7. Break and Continue</a></li>
<li><a href="#org9602626">3.8. Goto and labels</a></li>
</ul>
</li>
<li><a href="#org27a52d8">4. Functions and Program Structure</a>
<ul>
<li><a href="#orgf315de9">4.1. Basics of Functions</a></li>
<li><a href="#orgbf10746">4.2. Functions Returning Non-integers</a></li>
<li><a href="#orga12808a">4.3. External Variables</a></li>
<li><a href="#orgd82a4ea">4.4. Scope Rules</a></li>
<li><a href="#org8e43e06">4.5. Header Files</a></li>
<li><a href="#org43b4574">4.6. Static Variables</a></li>
<li><a href="#orga9bc954">4.7. Register Variables</a></li>
<li><a href="#org096d582">4.8. Block Structure</a></li>
<li><a href="#orga559353">4.9. Initialization</a></li>
<li><a href="#org58aa25e">4.10. Recursion</a></li>
<li><a href="#org069eeb3">4.11. The C preprocessor</a>
<ul>
<li><a href="#orgecfefc7">4.11.1. File Inclusion</a></li>
<li><a href="#orgd9ca570">4.11.2. Macro Substitution</a></li>
<li><a href="#orgf621766">4.11.3. Conditional Inclusion</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3c7f6e3">5. Pointers and Arrays</a>
<ul>
<li><a href="#org5fc3b28">5.1. Pointers and Addresses</a></li>
<li><a href="#org007e54a">5.2. Pointers and Function Arguments</a></li>
<li><a href="#org731e7e2">5.3. Pointers and Arrays</a></li>
<li><a href="#org9c2ed23">5.4. Address Arithmetic</a></li>
<li><a href="#orga51c1c7">5.5. Character Pointers and Functions</a></li>
<li><a href="#org0dbed1a">5.6. Pointer Arrays: Pointers to Pointers</a></li>
<li><a href="#org9321559">5.7. Multi-dimentional Arrays</a></li>
<li><a href="#org41c9c17">5.8. Initialization of Pointer Arrays</a></li>
<li><a href="#org7abd336">5.9. Pointers vs. Multi-dimensional Arrays</a></li>
<li><a href="#org49d1792">5.10. Command-line Arguments</a></li>
<li><a href="#org223e951">5.11. Pointers to Functions</a></li>
<li><a href="#orgb2f2e96">5.12. Complicated Declarations</a></li>
</ul>
</li>
<li><a href="#org7340642">6. Structures</a>
<ul>
<li><a href="#orgc587f35">6.1. Basics of Structures</a></li>
<li><a href="#org94b653e">6.2. Structures and Functions</a></li>
<li><a href="#org263f715">6.3. Arrays of Structures</a></li>
<li><a href="#org13e87d6">6.4. Pointers to Structures</a></li>
<li><a href="#org962d990">6.5. Self-referential Structure</a></li>
<li><a href="#org8d0d667">6.6. Table Lookup</a></li>
<li><a href="#org747bce6">6.7. Typedef</a></li>
<li><a href="#org4187f53">6.8. Unions</a></li>
<li><a href="#orgbbd3ebe">6.9. Bit-fields</a></li>
</ul>
</li>
<li><a href="#org7eb19f7">7. Input and Output</a>
<ul>
<li><a href="#org35fd43d">7.1. Standard Input and Output</a></li>
<li><a href="#org900cf5b">7.2. Formatted Output - printf</a></li>
<li><a href="#orgd54c27f">7.3. Variable-length Argument Lists</a></li>
<li><a href="#org2b4e30e">7.4. Formatted Input -Scanf</a></li>
<li><a href="#org252788f">7.5. File Access</a></li>
<li><a href="#org02788e5">7.6. Error Handling - Stderr and Exit</a></li>
<li><a href="#org010d435">7.7. Line Input and Output</a></li>
<li><a href="#orgd73985b">7.8. Miscellaneous Functions</a>
<ul>
<li><a href="#org8c88576">7.8.1. String Operations</a></li>
<li><a href="#orgdf4f689">7.8.2. Character Class Testing and Conversion</a></li>
<li><a href="#org5748b17">7.8.3. Ungetc</a></li>
<li><a href="#org2b41226">7.8.4. Command Execution</a></li>
<li><a href="#orgef3ae59">7.8.5. Storage Manegement</a></li>
<li><a href="#orgb87b9f0">7.8.6. Mathematical Functions</a></li>
<li><a href="#org8fe15dc">7.8.7. Random Number Generation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8bca6c7">8. The UNIX System Interface</a>
<ul>
<li><a href="#orgeeba70a">8.1. File Descriptors</a></li>
<li><a href="#orgb011d70">8.2. Low Level I/O - Read and Write</a></li>
<li><a href="#org109ce11">8.3. Open, Create, Close, Unlink</a></li>
<li><a href="#org20f011b">8.4. Random Access -Lseek</a></li>
<li><a href="#org9a8f834">8.5. Example - An Implementation of fopen</a></li>
<li><a href="#org145be02">8.6. Example - Listing Directories</a></li>
<li><a href="#org90baca5">8.7. Example - A Storage Allocator</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgad5a2ac" class="outline-2">
<h2 id="orgad5a2ac"><span class="section-number-2">1</span> A Tutorial Instroduction</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org11ea7bf" class="outline-3">
<h3 id="org11ea7bf"><span class="section-number-3">1.1</span> Getting Started</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The only way to learn a new programming language is by writing programs in it.<br />
</p>

<p>
hello.c:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #00ff7f;">main</span>()
{
  printf(<span style="color: #ffa07a;">"hello, world\n"</span>);
}

</pre>
</div>

<p>
Compile it:<br />
</p>
<div class="org-src-container">
<pre class="src src-sh">cc hello.c
</pre>
</div>

<p>
Run the output file:<br />
</p>
<pre class="example">
./a.out
</pre>

<p>
Result:<br />
</p>
<pre class="example">
hello, world
</pre>

<p>
A C program consists of <b>functions</b> and <b>variables</b>. A function contains <b>statements</b> that specify the computing operations to be done, and variables store values used during the computation.<br />
</p>


<p>
Normally you are at liberty to give functions whatever names you like, but "<code>main</code>" is special - your program begins executing at the beginning of main. This means that every program must have a <code>main</code> somewhere.<br />
</p>

<p>
A function is called by naming it, followed by a parenthesized list of arguments.<br />
</p>
</div>
</div>

<div id="outline-container-orgfa02ff1" class="outline-3">
<h3 id="orgfa02ff1"><span class="section-number-3">1.2</span> Variables and Arithmetic Expressions</h3>
<div class="outline-text-3" id="text-1-2">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">print Fahrenheit-Celsius table</span>
<span style="color: #cd853f;">   for fahr = 0, 20, ..., 300 </span><span style="color: #cd853f;">*/</span>
<span style="color: #00ff7f;">main</span>()
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">fahr</span>, <span style="color: #9acd32;">celsius</span>;
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">lower</span>, <span style="color: #9acd32;">upper</span>, <span style="color: #9acd32;">step</span>;

  lower = 0;                    <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">lower limit of temperature scale </span><span style="color: #cd853f;">*/</span>
  upper = 300;                  <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">upper limit </span><span style="color: #cd853f;">*/</span>
  step = 20;                    <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">step size </span><span style="color: #cd853f;">*/</span>

  fahr = lower;
  <span style="color: #20b2aa; font-weight: bold;">while</span> (fahr &lt;= upper) {
    celsius = 5 * (fahr-32) / 9;
    printf(<span style="color: #ffa07a;">"%d\t%d\n"</span>, fahr, celsius);
    fahr = fahr + step;
  }
}

</pre>
</div>

<p>
In C, all variables must be declared before they are used, usually at the beginning of the function before any executable statements. A <b>declaration</b> announces the properites of variables; it consists of a name and a list of variables.<br />
</p>

<p>
Computation in the temperature conversion program begins with the <b>assignment statements</b>,<br />
</p>
<div class="org-src-container">
<pre class="src src-C">lower = 0;
upper = 300;
step = 20;
</pre>
</div>
<p>
which set the variables to their initial values.<br />
</p>

<p>
Individual statements are terminated by semicolons.<br />
</p>




<p>
printf:<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">%d</td>
<td class="org-left">print as decimal integer</td>
</tr>

<tr>
<td class="org-left">%6d</td>
<td class="org-left">print as decimal integer, at least 6 characters wide</td>
</tr>

<tr>
<td class="org-left">%f</td>
<td class="org-left">print as floating point</td>
</tr>

<tr>
<td class="org-left">%6f</td>
<td class="org-left">print as floating point, at least 6 characters wide</td>
</tr>

<tr>
<td class="org-left">%.2f</td>
<td class="org-left">print as floating point, 2 characters after decimal point</td>
</tr>

<tr>
<td class="org-left">%6.2f</td>
<td class="org-left">print as floating point, at least 6 wide and 2 after decimal point</td>
</tr>

<tr>
<td class="org-left">%o</td>
<td class="org-left">print as octal</td>
</tr>

<tr>
<td class="org-left">%x</td>
<td class="org-left">print as hexadecimal</td>
</tr>

<tr>
<td class="org-left">%c</td>
<td class="org-left">print as character</td>
</tr>

<tr>
<td class="org-left">%s</td>
<td class="org-left">print as character string</td>
</tr>

<tr>
<td class="org-left">%%</td>
<td class="org-left">print as itself</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-orge74fc78" class="outline-3">
<h3 id="orge74fc78"><span class="section-number-3">1.3</span> The for statement</h3>
<div class="outline-text-3" id="text-1-3">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">print Fahrenheit-Celsius table </span><span style="color: #cd853f;">*/</span>
<span style="color: #00ff7f;">main</span>()
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">fahr</span>;

  <span style="color: #20b2aa; font-weight: bold;">for</span> (fahr = 0; fahr &lt;= 300; fahr = fahr + 20)
    printf(<span style="color: #ffa07a;">"%3d %6.1f\n"</span>, fahr, (5.0/9.0)*(fahr-32));
}

</pre>
</div>

<p>
a general rule:<br />
in any context where it is permissible to use the value of some type, you can use a more complicated expression of that type. Since the third arugment of <code>printf</code> must be a floating-point value to match the <code>%6.1f</code>, any floating-point expreesion can occur here.<br />
</p>
</div>
</div>


<div id="outline-container-org933e1a0" class="outline-3">
<h3 id="org933e1a0"><span class="section-number-3">1.4</span> Symbolic Constants</h3>
<div class="outline-text-3" id="text-1-4">
<p>
It's bad practice to bury "magic numbers" like 300 and 20 in a program; they convey little information to someone who might have to read the program later, and they are hard to change in a systematic way. One way to deal with magic numbers is to give them meaningful names. A <code>#define</code> line defines a <b>symbolic name</b> or <b>symbolic constant</b> to be a particular string of characters:<br />
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">name</span> replacement list
</pre>
</div>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">LOWER</span> 0
<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">UPPER</span> 300
<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">STEP</span> 20

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">print Fahrenheit-Celsius table </span><span style="color: #cd853f;">*/</span>
<span style="color: #00ff7f;">main</span>()
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">fahr</span>;

  <span style="color: #20b2aa; font-weight: bold;">for</span> (fahr = LOWER; fahr &lt;= UPPER; fahr = fahr + STEP)
    printf(<span style="color: #ffa07a;">"%3d %6.1f\n"</span>, fahr, (5.0/9.0)*(fahr-32));
}

</pre>
</div>
</div>
</div>
<div id="outline-container-org8e6fc49" class="outline-3">
<h3 id="org8e6fc49"><span class="section-number-3">1.5</span> Character Input and Output</h3>
<div class="outline-text-3" id="text-1-5">
<p>
The model of input and output supported by the standard library is very simple. Text input or output, regardless of where it originates or where it goes to, is dealt with as streams of characters. A <b>text stream</b> is a sequence of characters divided into lines; each line consists of zero or more characters followed by a newline character. It is the responsibility of the library to make each input or output stream confirm this model; the C programmer using the library need not worry about how lines are represented outside the program.<br />
</p>

<p>
The standard library provides several functions for reading or writing one character at a time, of which getchar and putchar are the simplest. Each time it is called, getchar reads the next input character from a text stream and returns that as its value. That is, after<br />
</p>
<div class="org-src-container">
<pre class="src src-C">c = getchar();
</pre>
</div>
<p>
the variable c contains the next character of input.<br />
</p>

<p>
The function putchar prints a character each time it is called:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00ff7f;">putchar</span>(c);
</pre>
</div>
<p>
prints the contents of the integer variable c as a character, usually on the screen.<br />
</p>
</div>

<div id="outline-container-orgd850ff8" class="outline-4">
<h4 id="orgd850ff8"><span class="section-number-4">1.5.1</span> File Copying</h4>
<div class="outline-text-4" id="text-1-5-1">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">copy input to output; 1st version </span><span style="color: #cd853f;">*/</span>
<span style="color: #00ff7f;">main</span>()
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">c</span>;

  c = getchar();
  <span style="color: #20b2aa; font-weight: bold;">while</span> (c!= EOF) {
    putchar(c);
    c = getchar();
  }
}

</pre>
</div>

<p>
In C, any assignment, such as<br />
</p>
<div class="org-src-container">
<pre class="src src-C">c = getchar();
</pre>
</div>
<p>
is an expression that has a value, which is the value of the left hand side after the assignment. This menas that a assignment can appear as part of a larger expression.<br />
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">copy input to output; 2nd version </span><span style="color: #cd853f;">*/</span>
<span style="color: #00ff7f;">main</span>()
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">c</span>;

  printf(<span style="color: #ffa07a;">"The value of EOF: %d\n"</span>, EOF);
  <span style="color: #20b2aa; font-weight: bold;">while</span> ((c = getchar()) != EOF) {
    putchar(c);
  }
}

</pre>
</div>
</div>
</div>

<div id="outline-container-org123922f" class="outline-4">
<h4 id="org123922f"><span class="section-number-4">1.5.2</span> Character Counting</h4>
<div class="outline-text-4" id="text-1-5-2">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">count characters in input; 1st version </span><span style="color: #cd853f;">*/</span>
<span style="color: #00ff7f;">main</span>()
{
  <span style="color: #9370db;">long</span> <span style="color: #9acd32;">nc</span>;

  nc = 0;
  <span style="color: #20b2aa; font-weight: bold;">while</span> (getchar() != EOF)
    ++nc;
  printf(<span style="color: #ffa07a;">"%ld\n"</span>, nc);
}

</pre>
</div>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">count characters in input; 1st version </span><span style="color: #cd853f;">*/</span>
<span style="color: #00ff7f;">main</span>()
{
  <span style="color: #9370db;">double</span> <span style="color: #9acd32;">nc</span>;


  <span style="color: #20b2aa; font-weight: bold;">for</span> (nc = 0; getchar() != EOF; ++nc)
    ;
  printf(<span style="color: #ffa07a;">"%.0f\n"</span>, nc);
}

</pre>
</div>
</div>
</div>

<div id="outline-container-orge977704" class="outline-4">
<h4 id="orge977704"><span class="section-number-4">1.5.3</span> Line Counting</h4>
<div class="outline-text-4" id="text-1-5-3">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">count lines in input </span><span style="color: #cd853f;">*/</span>
<span style="color: #00ff7f;">main</span>()
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">c</span>, <span style="color: #9acd32;">nl</span>;

  nl = 0;
  <span style="color: #20b2aa; font-weight: bold;">while</span> ((c = getchar()) != EOF)
    <span style="color: #20b2aa; font-weight: bold;">if</span> (c == <span style="color: #ffa07a;">'\n'</span>)
      ++nl;
  printf(<span style="color: #ffa07a;">"%d\n"</span>, nl);
}

</pre>
</div>

<p>
A character written between single quotes represents an integer value equal to the numberical value of the character in the machine's character set. This is called a <b>character constant</b>.<br />
</p>
</div>
</div>


<div id="outline-container-org1eb35b0" class="outline-4">
<h4 id="org1eb35b0"><span class="section-number-4">1.5.4</span> Word Counting</h4>
<div class="outline-text-4" id="text-1-5-4">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">IN</span> 1                    <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">inside a word </span><span style="color: #cd853f;">*/</span>
<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">OUT</span> 0                   <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">outside a word </span><span style="color: #cd853f;">*/</span>

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">count lines, words, and characters in input </span><span style="color: #cd853f;">*/</span>
<span style="color: #00ff7f;">main</span>()
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">c</span>, <span style="color: #9acd32;">nl</span>, <span style="color: #9acd32;">nw</span>, <span style="color: #9acd32;">nc</span>, <span style="color: #9acd32;">state</span>;     <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">character, num line, num word, num character </span><span style="color: #cd853f;">*/</span>

  state = OUT;
  nl = nw = nc = 0;
  <span style="color: #20b2aa; font-weight: bold;">while</span> ((c = getchar()) != EOF) {
    ++nc;
    <span style="color: #20b2aa; font-weight: bold;">if</span> (c == <span style="color: #ffa07a;">'\n'</span>)
      ++nl;
    <span style="color: #20b2aa; font-weight: bold;">if</span> (c == <span style="color: #ffa07a;">' '</span> || c == <span style="color: #ffa07a;">'\n'</span> || c == <span style="color: #ffa07a;">'\t'</span>)
      state = OUT;
    <span style="color: #20b2aa; font-weight: bold;">else</span> <span style="color: #20b2aa; font-weight: bold;">if</span> (state == OUT) {
      state = IN;
      ++nw;
    }
  }
  printf(<span style="color: #ffa07a;">"%d %d %d\n"</span>, nl, nw, nc);
}

</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org8059e6e" class="outline-3">
<h3 id="org8059e6e"><span class="section-number-3">1.6</span> Arrays</h3>
<div class="outline-text-3" id="text-1-6">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">count digits, white space, others </span><span style="color: #cd853f;">*/</span>
<span style="color: #00ff7f;">main</span>()
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">c</span>, <span style="color: #9acd32;">i</span>, <span style="color: #9acd32;">nwhite</span>, <span style="color: #9acd32;">nother</span>;
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">ndigit</span>[10];

  nwhite = nother = 0;
  <span style="color: #20b2aa; font-weight: bold;">for</span> (i = 0; i &lt; 10; ++i)
    ndigit[i] = 0;              <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">init </span><span style="color: #cd853f;">*/</span>

  <span style="color: #20b2aa; font-weight: bold;">while</span> ((c = getchar()) != EOF) {
    <span style="color: #20b2aa; font-weight: bold;">if</span> (c &gt;= <span style="color: #ffa07a;">'0'</span> &amp;&amp; c &lt;= <span style="color: #ffa07a;">'9'</span>)
      ++ndigit[c-<span style="color: #ffa07a;">'0'</span>];
    <span style="color: #20b2aa; font-weight: bold;">else</span> <span style="color: #20b2aa; font-weight: bold;">if</span> (c == <span style="color: #ffa07a;">' '</span> || c == <span style="color: #ffa07a;">'\n'</span> || c == <span style="color: #ffa07a;">'\t'</span>)
      ++nwhite;
    <span style="color: #20b2aa; font-weight: bold;">else</span>
      ++nother;
  }

  printf(<span style="color: #ffa07a;">"digits ="</span>);
  <span style="color: #20b2aa; font-weight: bold;">for</span> (i = 0; i &lt; 10; ++i)
    printf(<span style="color: #ffa07a;">" %d"</span>, ndigit[i]);
  printf(<span style="color: #ffa07a;">", while space = %d, other = %d\n"</span>, nwhite, nother);
}

</pre>
</div>
</div>
</div>


<div id="outline-container-orgaea67e7" class="outline-3">
<h3 id="orgaea67e7"><span class="section-number-3">1.7</span> Functions</h3>
<div class="outline-text-3" id="text-1-7">
<p>
A function provides a convenient way to encapsulate some computation, which can then be used without worrying about its implementation. With properly designed functions, it is possible to ignore <b>how</b> a job is done; knowing <b>what</b> is done is sufficient.<br />
</p>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">power</span>(<span style="color: #9370db;">int</span> <span style="color: #9acd32;">m</span>, <span style="color: #9370db;">int</span> <span style="color: #9acd32;">n</span>);

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">test power function </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">main</span>()
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">i</span>;

  <span style="color: #20b2aa; font-weight: bold;">for</span> (i = 0; i &lt; 10; ++i)
    printf(<span style="color: #ffa07a;">"%d %d %d\n"</span>, i, power(2,i), power(-3,i));
  <span style="color: #20b2aa; font-weight: bold;">return</span> 0;
}

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">power: raise base to n-th power; n &gt;= 0 </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">power</span>(<span style="color: #9370db;">int</span> <span style="color: #9acd32;">base</span>, <span style="color: #9370db;">int</span> <span style="color: #9acd32;">n</span>)
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">i</span>, <span style="color: #9acd32;">p</span>;

  p = 1;
  <span style="color: #20b2aa; font-weight: bold;">for</span> (i = 1; i &lt;= n; ++i)
    p = p * base;
  <span style="color: #20b2aa; font-weight: bold;">return</span> p;
}

</pre>
</div>

<p>
The declaration<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #00ff7f;">power</span>(<span style="color: #9370db;">int</span> <span style="color: #9acd32;">m</span>, <span style="color: #9370db;">int</span> <span style="color: #9acd32;">n</span>);
</pre>
</div>
<p>
just before <code>main</code> says that <code>power</code> is a function that expects two <code>int</code> arguments and returns an <code>int</code>. This declaration, which is called a <b>function prototype</b>, has to agree with the difinition and uses of <code>power</code>. Indeed, parameter names are optional in a function prototype, so for the prototype we could have written<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #00ff7f;">power</span>(<span style="color: #9370db;">int</span>, <span style="color: #9370db;">int</span>);
</pre>
</div>
</div>
</div>


<div id="outline-container-orgdaf9589" class="outline-3">
<h3 id="orgdaf9589"><span class="section-number-3">1.8</span> Arguments - Call by Value</h3>
<div class="outline-text-3" id="text-1-8">
<p>
In C, all function arguments are passed "by value". This means that the called function is given the values of its arguments in teporary variables rather than the originals. This leads to some different properties than seen with "call by reference" language like Fortan or with <code>var</code> parameters in Pascal, in which the called routine has access to the original argument, not a local copy.<br />
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">power</span>(<span style="color: #9370db;">int</span> <span style="color: #9acd32;">m</span>, <span style="color: #9370db;">int</span> <span style="color: #9acd32;">n</span>);

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">test power function </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">main</span>()
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">i</span>;

  <span style="color: #20b2aa; font-weight: bold;">for</span> (i = 0; i &lt; 10; ++i)
    printf(<span style="color: #ffa07a;">"%d %d %d\n"</span>, i, power(2,i), power(-3,i));
  <span style="color: #20b2aa; font-weight: bold;">return</span> 0;
}

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">power: raise base to n-th power; n &gt;= 0; version 2 </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">power</span>(<span style="color: #9370db;">int</span> <span style="color: #9acd32;">base</span>, <span style="color: #9370db;">int</span> <span style="color: #9acd32;">n</span>)
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">p</span>;

  <span style="color: #20b2aa; font-weight: bold;">for</span> (p = 1; n &gt; 0; --n)
    p = p * base;
  <span style="color: #20b2aa; font-weight: bold;">return</span> p;
}

</pre>
</div>


<p>
The parameter <code>n</code> is used as a temporary variable, and is counted down (a <code>for</code> loop that runs backwards) until it becomes zero; there is no longer a need for the variable <code>i</code>. Whatever is done to <code>n</code> inside <code>power</code> has no effect on the argument that <code>power</code> was originally called with.<br />
</p>

<p>
The story is different for arrays. When the name of an array is used as an argument, the value passed to the function is the location or address of the beginning of the array - there is no copying of array elements.<br />
</p>
</div>
</div>

<div id="outline-container-org0a02a84" class="outline-3">
<h3 id="org0a02a84"><span class="section-number-3">1.9</span> Character Arrays</h3>
<div class="outline-text-3" id="text-1-9">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">MAXLINE</span> 1000            <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">maximum input line length </span><span style="color: #cd853f;">*/</span>

<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">getline</span>(<span style="color: #9370db;">char</span> <span style="color: #9acd32;">line</span>[], <span style="color: #9370db;">int</span> <span style="color: #9acd32;">maxline</span>);
<span style="color: #9370db;">void</span> <span style="color: #00ff7f;">copy</span>(<span style="color: #9370db;">char</span> <span style="color: #9acd32;">to</span>[], <span style="color: #9370db;">char</span> <span style="color: #9acd32;">from</span>[]);

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">print the longest input line </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">main</span>()
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">len</span>;                      <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">current line length </span><span style="color: #cd853f;">*/</span>
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">max</span>;                      <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">maximum length seen sor far </span><span style="color: #cd853f;">*/</span>
  <span style="color: #9370db;">char</span> <span style="color: #9acd32;">line</span>[MAXIMUM];           <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">current input line </span><span style="color: #cd853f;">*/</span>
  <span style="color: #9370db;">char</span> <span style="color: #9acd32;">longest</span>[MAXIMUM];        <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">longest line saved here </span><span style="color: #cd853f;">*/</span>

  max = 0;
  <span style="color: #20b2aa; font-weight: bold;">while</span> ((len = getline(line, MAXLINE)) &gt; 0)
    <span style="color: #20b2aa; font-weight: bold;">if</span> (len &gt; max) {
      max = len;
      copy(longest, line);
    }

  <span style="color: #20b2aa; font-weight: bold;">if</span> (max &gt; 0)                  <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">there was a line </span><span style="color: #cd853f;">*/</span>
    printf(<span style="color: #ffa07a;">"%s"</span>, longest);
}

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">getline: read a line into s, return length </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">getline</span>(<span style="color: #9370db;">char</span> <span style="color: #9acd32;">s</span>[], <span style="color: #9370db;">int</span> <span style="color: #9acd32;">lim</span>)
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">c</span>, <span style="color: #9acd32;">i</span>;

  <span style="color: #20b2aa; font-weight: bold;">for</span> (i = 0; i &lt; lim-1 &amp;&amp; (c=getchar()) != EOF &amp;&amp; c != <span style="color: #ffa07a;">'\n'</span>; ++i)
    s[i] = c;
  <span style="color: #20b2aa; font-weight: bold;">if</span> (c == <span style="color: #ffa07a;">'\n'</span>) {
    s[i] = c;
    ++i;
  }
  s[i] = <span style="color: #ffa07a;">'\0'</span>;
  <span style="color: #20b2aa; font-weight: bold;">return</span> i;
}

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">copy: copy 'from' into 'to'; assume 'to' is big enough </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">void</span> <span style="color: #00ff7f;">copy</span>(<span style="color: #9370db;">char</span> <span style="color: #9acd32;">to</span>[], <span style="color: #9370db;">char</span> <span style="color: #9acd32;">from</span>[])
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">i</span>;

  i = 0;
  <span style="color: #20b2aa; font-weight: bold;">while</span> ((to[i] = from[i]) != <span style="color: #ffa07a;">'\0'</span>)
    ++i;
}

</pre>
</div>

<p>
The functions <code>getline</code> and <code>copy</code> are declared at the beginning of the program, which we assume is considered in one file.<br />
</p>

<p>
The length of the array <code>s</code> is not necessary in <code>getline</code> since its size is set in <code>main</code>.<br />
</p>

<p>
<code>getline</code> puts the character '\0' (the null character, whose value is zero) at the end of the array it is creating, to mark the end of the string of characters. This conversion is also used by the C language: when a string constant like<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffa07a;">"hello\n"</span>
</pre>
</div>
<p>
appears in a C program, it is stored as an array of characters containing the characters in the string and terminated with a '\0' to mark the end.<br />
</p>
<pre class="example">
h e l l o \n \0
</pre>
</div>
</div>


<div id="outline-container-org7f8e2ef" class="outline-3">
<h3 id="org7f8e2ef"><span class="section-number-3">1.10</span> External Variables and Scope</h3>
<div class="outline-text-3" id="text-1-10">
<p>
Each local variable in a function comes into existence only when the function is called, and disappears when the function is exited. This is why such variables are usually known as <b>automatic</b> variables.<br />
</p>

<p>
As an alternative to automatic variables, it is possible to define variables that are <b>external</b> to all functions, that is, variables that can be accessed by name by any function.<br />
</p>

<p>
An external variable must be <b>defined</b>, exactly once, outside of any function; this sets aside storage for it. The variable must also be <b>declared</b> in each function that wants to access it; this states the type of the variable. he declaration may be an explicit <code>extern</code> statement or may be implicit from context.<br />
</p>

<p>
If the definition of the external variable occurs in the source file before its use in a particular function, then there is no need for an <code>extern</code> declaration in the function.<br />
</p>

<p>
If the program is in several source files, and a variable is defined in file1 and used in file2 and file3, then <code>extern</code> declarations are needed in file2 and file3 to connect the occurrences of the variable. The usual practice is to collect <code>extern</code> declarations of variables and functions in a separate file, historically called a <b>header</b>, that is included by <code>#include</code> at the front of each source file. The suffix <code>.h</code> is conventional for header names.<br />
</p>

<p>
``Definition'' refers to the place where the variable is created or assigned storage; ``declaration'' refers to places where the nature of the variable is stated but no storage is allocated.<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org4c903dd" class="outline-2">
<h2 id="org4c903dd"><span class="section-number-2">2</span> Types, Operators and Expressions</h2>
<div class="outline-text-2" id="text-2">
<p>
Variables and constants are the basic data objects manipulated in a program. Declarations list the variables to be used, and state what type they have and perhaps what their initial values are. Operators specify what is to be done to them. Expressions combine variables and constants to produce new values. The type of an object determines the set of values it can have and what operations can be performed on it.<br />
</p>
</div>

<div id="outline-container-org206f4f2" class="outline-3">
<h3 id="org206f4f2"><span class="section-number-3">2.1</span> Variable Names</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Names are made up of letters and digits; the first character must be a letter. The underscore ``_'' counts as a letter.<br />
</p>

<p>
It's wise to choose variable names that are related to the purpose of the variable. We tend to use short names for local variables, especially loop indices, and longer names for external variables.<br />
</p>
</div>
</div>

<div id="outline-container-org5f415be" class="outline-3">
<h3 id="org5f415be"><span class="section-number-3">2.2</span> Data Types and Sizes</h3>
<div class="outline-text-3" id="text-2-2">
<p>
There are only a few basic data types in C:<br />
</p>
<dl class="org-dl">
<dt>char</dt><dd>a single byte, capable of holding one character in the local character set<br /></dd>
<dt>int</dt><dd>an integer, typically reflecting the natural size of integers on the host machine<br /></dd>
<dt>float</dt><dd>single-precision floating point<br /></dd>
<dt>double</dt><dd>double-precision floating point<br /></dd>
</dl>

<p>
In addition, there are a number of qualifiers that can be applied to these basic types. <code>short</code> and <code>long</code> apply to integers:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">short</span> <span style="color: #9370db;">int</span> <span style="color: #9acd32;">sh</span>;
<span style="color: #9370db;">long</span> <span style="color: #9370db;">int</span> <span style="color: #9acd32;">counter</span>;
</pre>
</div>
<p>
The word <code>int</code> can be omitted in such declarations, and typically it is.<br />
</p>

<p>
The qualifier <code>signed</code> or <code>unsigned</code> may be applied to <code>char</code> or any integer.<br />
</p>

<pre class="example">
The standard headers &lt;limits.h&gt; and &lt;float.h&gt; contain symbolic constant for all of these sizes, 
along with other properies of the machine and compiler.
</pre>
</div>
</div>





<div id="outline-container-orgb7be120" class="outline-3">
<h3 id="orgb7be120"><span class="section-number-3">2.3</span> Constants</h3>
<div class="outline-text-3" id="text-2-3">
<p>
An integer constant like <code>1234</code> is an <code>int</code>. A <code>long</code> constant is written with terminal <code>l</code> or <code>L</code> as in <code>123456789L</code>. Unsigned constants are written with a terminal <code>u</code> or <code>U</code>.<br />
</p>
<pre class="example">
An integer constant too big to fit into an int will also be taken as a long.
</pre>

<p>
Floating-point constants contain a decimal point (<code>123.4</code>) or an exponent (<code>1e-2</code>) or both; their type is <code>double</code>, unless suffixed. The suffix <code>f</code> or <code>F</code> indicates constant; <code>l</code> or <code>L</code> indicate a <code>long double</code>.<br />
</p>

<p>
The value  of an integer can be specified in octal or hexadecimal instead of decimal. A leading <code>0</code> (zero) on an integer constant means octal; a leading <code>0x</code> or <code>0X</code> means hexadecimal. For example, decimal 31 can be written in <code>037</code> in octal and <code>0x1f</code> or <code>0x1F</code> in hex. Octal and hexadecimal constants may also be followed by <code>L</code> to make long and <code>U</code> to make them <code>unsigned</code>: <code>0XFUL</code> is an <b>unsigned long</b> constant with value 15 decimal.<br />
</p>

<p>
A <code>character constant</code> is an integer, written as one character within a single quotes, such as <code>'x'</code>. The value of a character constant is the numeric value of the character in the machine's character set.<br />
</p>

<p>
Certain characters can be represented in character and string constants by escape sequences like <code>\n</code> (newline); these sequences look like two characters, but represent only one.<br />
</p>

<p>
An arbitrary byte-sized bit pattern can be specified by<br />
</p>
<pre class="example">
'\ooo'
</pre>
<p>
where ooo is one of three digits(0..7) or by<br />
</p>
<pre class="example">
'\xhh'
</pre>
<p>
where hh is one or more hexcadecimal digits(0..9, a..f, A..F).<br />
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">VTAB</span> <span style="color: #ff69b4; font-weight: bold;">'</span>\013<span style="color: #ff69b4; font-weight: bold;">'</span>             <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">ASCII vertical tab </span><span style="color: #cd853f;">*/</span>
<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">BELL</span> <span style="color: #ff69b4; font-weight: bold;">'</span>007<span style="color: #ff69b4; font-weight: bold;">'</span>              <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">ASCII bell character </span><span style="color: #cd853f;">*/</span>

<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">VTAB</span> <span style="color: #ff69b4; font-weight: bold;">'</span>\xb<span style="color: #ff69b4; font-weight: bold;">'</span>              <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">ASCII vertical tab </span><span style="color: #cd853f;">*/</span>
<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">BELL</span> <span style="color: #ff69b4; font-weight: bold;">'</span>\x7<span style="color: #ff69b4; font-weight: bold;">'</span>              <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">ASCII bell character </span><span style="color: #cd853f;">*/</span>
</pre>
</div>


<div class="figure">
<p><img src="pics/escape-sequences.png" alt="escape-sequences.png" /><br />
</p>
</div>


<p>
The character constant <code>'\0'</code> represents the character with value zero, the null character. <code>'\0'</code> is often written instead of <code>0</code> to emphasize the character nature of some expression, but the numeric value is just <code>0</code>.<br />
</p>

<p>
A <b>constant expression</b> is an expression that involves only constants. Such expressions may be evaluated at during compilation rather than run-time, and accordingly may be used in any place that a constant can occur, as in<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">MAXLINE</span> 1000
<span style="color: #9370db;">char</span> <span style="color: #9acd32;">line</span>[MAXLINE+1];
</pre>
</div>


<p>
A string constant, or string literal, is a sequence of zero or more characters surrounded by double quotes, as in<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffa07a;">"I am a string"</span>
</pre>
</div>

<p>
The quotes are not part of the string, but serve only to delimit it. The same escape sequences used in character constants apply in strings; <code>\"</code> represents the double-quote character. String constants can be concatenated at compile time:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffa07a;">"hello, "</span> <span style="color: #ffa07a;">"world"</span>
<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">is equivalent to </span><span style="color: #cd853f;">*/</span>
<span style="color: #ffa07a;">"hello, world"</span>
</pre>
</div>


<p>
Technically, a string constant is an array of characters. The internal representation of a string has a null character <code>'\0'</code> at the end, so the physical storage required is one more than the number of characters written between the quotes. This representation means that there is no limit to how long a string can be, but programs must scan a string completely to determine its length. The standard library function <code>strlen(s)</code> returns the length of its character string argument <code>s</code>, excluding the terminal <code>'\0'</code>.<br />
</p>

<p>
Be careful to distinguish between a character constant and a string that contains a single character: <code>'x'</code> is not the same as <code>"x"</code>. The former is an integer, used to produce the numeric value of the letter x in the machine's character set. The latter is an array of characters that contains one character (the letter x) and a '\0'.<br />
</p>


<p>
There is one other kind of constant, the <b>enumeration constant</b>. An enumeration is a list of constant integer values, as in<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">enum</span> <span style="color: #9370db;">boolean</span> { <span style="color: #9acd32;">NO</span>, <span style="color: #9acd32;">YES</span> };
</pre>
</div>
<p>
The first name in an enum has value 0, the next 1, and so on, unless explicit values are specified. If not all values are specified, unspecified values continue the progression from the last specified value.<br />
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">enum</span> <span style="color: #9370db;">escapes</span> { <span style="color: #9acd32;">BELL</span> = <span style="color: #ffa07a;">'\a'</span>, <span style="color: #9acd32;">BACKSPACE</span> = <span style="color: #ffa07a;">'\b'</span>, <span style="color: #9acd32;">TAB</span> = <span style="color: #ffa07a;">'\t'</span>, <span style="color: #9acd32;">NEWLINE</span> = <span style="color: #ffa07a;">'\n'</span>, <span style="color: #9acd32;">VTAB</span> = <span style="color: #ffa07a;">'\v'</span>, <span style="color: #9acd32;">RETURN</span> = <span style="color: #ffa07a;">'\r'</span> };

<span style="color: #20b2aa; font-weight: bold;">enum</span> <span style="color: #9370db;">months</span> { <span style="color: #9acd32;">JAN</span> = 1, <span style="color: #9acd32;">FEB</span>, <span style="color: #9acd32;">MAR</span>, <span style="color: #9acd32;">APR</span>, <span style="color: #9acd32;">MAY</span>, <span style="color: #9acd32;">JUN</span>, <span style="color: #9acd32;">JUL</span>, <span style="color: #9acd32;">AUG</span>, <span style="color: #9acd32;">SEP</span>, <span style="color: #9acd32;">OCT</span>, <span style="color: #9acd32;">NOV</span>, <span style="color: #9acd32;">DEC</span> }; <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">FEB = 2, MAR = 3, etc. </span><span style="color: #cd853f;">*/</span>
</pre>
</div>

<p>
Enumerations provide a convenient way to associate constant values with names, an alternative to <code>#define</code> with the advantage that the values can be generated for you. Although variables of <code>enum</code> types may be declared, compilers need not check that what you store in such a variable is a valid value for the enumeration. Nevertheless, enumeration variables offer the chance of checking and so are often better than <code>#defines</code>. In addition, a debugger may be able to print values of enumeration variables in their symbolic form.<br />
</p>
</div>
</div>

<div id="outline-container-org7cbdbc6" class="outline-3">
<h3 id="org7cbdbc6"><span class="section-number-3">2.4</span> Declarations</h3>
<div class="outline-text-3" id="text-2-4">
<p>
All variables must be declared before use, although certain declarations can be made implicitly by content. A declaration specifies a type, and contains a list of one or more variables of that type, as in<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #9acd32;">lower</span>, <span style="color: #9acd32;">upper</span>, <span style="color: #9acd32;">step</span>;
<span style="color: #9370db;">char</span> <span style="color: #9acd32;">c</span>, <span style="color: #9acd32;">line</span>[1000];
</pre>
</div>

<p>
Variables can be distributed among declarations in any fashion;<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #9acd32;">lower</span>;
<span style="color: #9370db;">int</span> <span style="color: #9acd32;">upper</span>;
<span style="color: #9370db;">int</span> <span style="color: #9acd32;">step</span>;
<span style="color: #9370db;">char</span> <span style="color: #9acd32;">c</span>;
<span style="color: #9370db;">char</span> <span style="color: #9acd32;">line</span>[10000];
</pre>
</div>
<p>
The latter form takes more space, but is convenient for adding a <b>comment</b> to each declaration for subsequent modifications.<br />
</p>

<p>
A variable may also be initialized in its declaration. If the name is followed by an equals sign and an expression, the expression serves as an initializer, as in<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">char</span> <span style="color: #9acd32;">esc</span> = <span style="color: #ffa07a;">'\\'</span>;
<span style="color: #9370db;">int</span> <span style="color: #9acd32;">i</span> = 0;
<span style="color: #9370db;">int</span> <span style="color: #9acd32;">limie</span> = MAXLINE+1;
<span style="color: #9370db;">float</span> <span style="color: #9acd32;">eps</span> = 1.0e-5;
</pre>
</div>


<pre class="example">
What's meaning of the following sentences?
</pre>
<p>
If the variable in question is not automatic, the initialization is done once only, conceptionally before the program starts executing, and the initializer must be a constant expression. An explicitly initialized automatic variable is initialized each time the function or block it is in is entered; the initializer may be any expression. External and static variables are initialized to zero by default. Automatic variables for which is no explicit initializer have undefined (i.e., garbage) values.<br />
</p>


<p>
The qualifier const can be applied to the declaration of any variable to specify that its value will not be changed. For an array, the const qualifier says that the elements will not be altered.<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">const</span> <span style="color: #9370db;">double</span> <span style="color: #9acd32;">e</span> = 2.71828182845905;
<span style="color: #20b2aa; font-weight: bold;">const</span> <span style="color: #9370db;">char</span> <span style="color: #9acd32;">msg</span>[] = <span style="color: #ffa07a;">"warning: "</span>;
</pre>
</div>

<p>
The <code>const</code> declaration can also be used with array arguments, to indicate that the function does not change that array:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #00ff7f;">strlen</span>(<span style="color: #20b2aa; font-weight: bold;">const</span> <span style="color: #9370db;">char</span>[]);
</pre>
</div>
</div>
</div>

<div id="outline-container-org4bafe2b" class="outline-3">
<h3 id="org4bafe2b"><span class="section-number-3">2.5</span> Arithmetic Operators</h3>
<div class="outline-text-3" id="text-2-5">
<p>
The binary arithmetic operators are <code>+, -, *, /,</code> and the modulus operator <code>%</code>. Integer division truncates any fractional part.<br />
</p>

<p>
Arithmetic operators associate left to right.<br />
</p>
</div>
</div>


<div id="outline-container-org6435edd" class="outline-3">
<h3 id="org6435edd"><span class="section-number-3">2.6</span> Relational and Logical Operators</h3>
<div class="outline-text-3" id="text-2-6">
<p>
The relational operators are<br />
</p>
<pre class="example">
&gt; &gt;= &lt; &lt;=
</pre>

<p>
equality operators:<br />
</p>
<div class="org-src-container">
<pre class="src src-C">== !=
</pre>
</div>


<p>
logical operators:<br />
</p>
<div class="org-src-container">
<pre class="src src-C">&amp;&amp; ||
</pre>
</div>
<p>
Expressions connected by &amp;&amp; or || are evaluated left to right, and evaluation stops as soon as the truth or falsehood of the result is known. Most C programs rely on these properties.<br />
</p>


<p>
By definition, the numeric value of a relational or logical expression is 1 if the relation is true, and 0 if the relation is false.<br />
</p>

<p>
The <b>unary negation operator</b> <code>!</code> converts a non-zero operand into 0, and a zero operand in 1.<br />
</p>
</div>
</div>

<div id="outline-container-org9c63a16" class="outline-3">
<h3 id="org9c63a16"><span class="section-number-3">2.7</span> Type Conversions</h3>
<div class="outline-text-3" id="text-2-7">
<p>
When an operator has operands of different types, they are converted to a common type according to a small number of rules. In general, the only automatic conversions are those that convert a ``narrower'' operand into a ``wider'' one without losing information, such as converting an integer into floating point in an expression like <code>f + i</code>. Expressions that might lose information, like assigning a longer integer type to a shorter, or a floating-point type to an integer, may draw a warning, but they are not illegal.<br />
</p>

<p>
A char is just a small integer, so chars may be freely used in arithmetic expressions.<br />
</p>

<p>
The standard header <code>&lt;ctype.h&gt;</code> defines a family of functions that provides tests and conversions that independent of character set.<br />
</p>
<pre class="example">
tolower(c)
isdigit(c)
</pre>


<p>
The definition of C guarantees that any character in the machine's standard printing character set will never be negative, so there characters will always be positive quantities in expressions. But arbitrary bit patterns stored in character variables may appear to be negative on some machines, yet positive on others. For portability, specify signed or unsigned if non-character data is to be stored in <code>char</code> variables.<br />
</p>

<p>
Conversions take place across assignments; the value of the right side is converted to the type of the left, which is the type of the result.<br />
</p>

<p>
Since an argument of a function call is an expression, type conversion also takes place when arguments are passed to functions. In the absence of a function prototype, <code>char</code> and <code>short</code> become <code>int</code>, and <code>float</code> becomes <code>double</code>.<br />
</p>

<p>
Explicit type conversions can be forced in any expression, with a unary operator called a <code>cast</code>. In the construction<br />
</p>
<pre class="example">
(type name) expression
</pre>
<p>
the <b>expression</b> is converted to the named type. The precise meaning of a <code>cast</code> is as if the expression were assigned to a variable of the specified type, which is then used in inplace of the whole construction.<br />
</p>

<hr />
<p>
For example, the library routine <code>sqrt</code> expects a <code>double</code> argument, and will produce nonsense if inadvertently handled something else. (<code>sqrt</code> is declared in <code>&lt;math.h&gt;</code>.) So if <code>n</code> is an integer, we can use<br />
</p>

<div class="org-src-container">
<pre class="src src-C">sqrt((<span style="color: #9370db;">double</span>) n);
</pre>
</div>
<p>
to convert the value of <code>n</code> into <code>double</code> before passing it to <code>sqrt</code>.<br />
</p>
<pre class="example">
Note that the cast produces the value of n in the proper type; n itself is not altered.
</pre>
<hr />


<p>
If arguments are declared by a function prototype, as the normally should be, the declaration causes automatic coercion of any arguments when the function is called.<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">double</span> <span style="color: #00ff7f;">sqrt</span>(<span style="color: #9370db;">double</span>);

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">coerces the integer 2 into the double value 2.0 without need for a cast. </span><span style="color: #cd853f;">*/</span>
root2 = sqrt(2);
</pre>
</div>
</div>
</div>

<div id="outline-container-org76d25e5" class="outline-3">
<h3 id="org76d25e5"><span class="section-number-3">2.8</span> Increment and Decrement Operators</h3>
<div class="outline-text-3" id="text-2-8">
<p>
C provides two unusual operators for incrementing and decrementing variables. The increment operator ++ adds 1 to its operand, while the decrement operator &#x2013; subtracts 1.<br />
</p>


<hr />
<pre class="example">
The unusual aspect is that ++ and -- may be used either as prefix operators (++n), or postfix operators (n++). 
In both cases, the effect is to increment n.
But the expression ++n increments n before its value is used,
while n++ increments n after its value has been used.
This means that is a context where the value is being used, not just the effect, 
++n and n++ are different.
</pre>

<p>
If n is 5, then<br />
</p>
<div class="org-src-container">
<pre class="src src-C">x = n++;
</pre>
</div>
<p>
sets x to 5, but<br />
</p>
<div class="org-src-container">
<pre class="src src-C">x = ++n;
</pre>
</div>
<p>
sets x to 6. In both cases, n becomes 6. The increment and decrement operators can only be applied to variables; an expression like (i+j)++ is illegal.<br />
</p>

<p>
In a context where no value is wanted, just the incrementing effect, as in<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">if</span> (c == <span style="color: #ffa07a;">'\n'</span>)
  nl++;
</pre>
</div>
<p>
prefix and posfix are the same.<br />
</p>
<hr />
</div>
</div>


<div id="outline-container-orgce89958" class="outline-3">
<h3 id="orgce89958"><span class="section-number-3">2.9</span> Bitwise Operators</h3>
<div class="outline-text-3" id="text-2-9">
<p>
C provides six operators for bit manipulation; these may only be applied to integral operands, that is, <code>char, short, int</code>, and <code>long</code>, whether signed or unsigned.<br />
</p>

<pre class="example">
&amp;    bitwise AND
|    bitwise inclusive OR
^    bitwise exclusive OR
&lt;&lt;   left shift
&gt;&gt;   right shift
~    one's complement(unary)
</pre>

<p>
Right shifting an unsigned quantity always fits the vacated bits with zero. Right shifting a signed quantity will fill with bit signs (``arithmetic shift'') on some machines and with 0-bits (``logical shift'') on others.<br />
</p>

<p>
The unary operator ~ yields the one's complement of an integer; that is, it converts each 1-bit into a 0-bit and vice versa.<br />
</p>

<hr />
<div class="org-src-container">
<pre class="src src-C">x = x &amp; ~077
</pre>
</div>
<p>
sets the last six bits of x to zero. Note that <code>x &amp; ~077</code> is <b>independent of word length</b>, and is thus preferable to, for example, x &amp; 0177700, which assumes that x is a 16-bit quantity. The portable form involves no extra cost, since <code>~077</code> is a constant expression that can be evaluated at compile time.<br />
</p>
<hr />
</div>
</div>

<div id="outline-container-org7c89ff3" class="outline-3">
<h3 id="org7c89ff3"><span class="section-number-3">2.10</span> Assignment Operators and Exmpressions</h3>
<div class="outline-text-3" id="text-2-10">
<p>
An expression such as<br />
</p>
<div class="org-src-container">
<pre class="src src-C">i = i + 2;
</pre>
</div>
<p>
in which the variable on the left side is repeated immdediately on the right, can be written in the compressed from<br />
</p>
<div class="org-src-container">
<pre class="src src-C">i += 2;
</pre>
</div>
<p>
The operator += is called <b>assignment operator</b>.<br />
</p>

<p>
Most binary operators have a corresponding assignment operator <b>op=</b>, where <b>op</b> is one of<br />
</p>
<div class="org-src-container">
<pre class="src src-C">+ - * / % &lt;&lt; &gt;&gt; &amp; ^ |
</pre>
</div>


<p>
If <b>expr1</b> op <b>expr2</b> are expressions, then<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">expr1</span> <span style="color: #9acd32;">op</span>= expr2;
</pre>
</div>
<p>
is equivalent to<br />
</p>
<div class="org-src-container">
<pre class="src src-C">expr1 = (<span style="color: #9370db;">expr1</span>) <span style="color: #00ff7f;">os</span> (expr2)
</pre>
</div>
<p>
except that <b>expr1</b> is computed only <b>once</b>.<br />
</p>


<p>
In all such expressions, the type of an assignment expression is the type of its left operand, and the value is the value after the assignment.<br />
</p>
</div>
</div>

<div id="outline-container-orga77ebb7" class="outline-3">
<h3 id="orga77ebb7"><span class="section-number-3">2.11</span> Conditional Expressions</h3>
<div class="outline-text-3" id="text-2-11">
<p>
conditional expression: "?:"<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">if</span> (a &gt; b)
  z = a;
<span style="color: #20b2aa; font-weight: bold;">else</span>
  z = b;
</pre>
</div>
<p>
is equivalent to<br />
</p>
<div class="org-src-container">
<pre class="src src-C">z = (a &gt; b) ? a : b;
</pre>
</div>

<p>
The conditional expression often leads to succinct code.<br />
</p>
<div class="org-src-container">
<pre class="src src-C">  <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">prints n element of an array, 10 per line,</span>
<span style="color: #cd853f;">  with each column separated by one blank,</span>
<span style="color: #cd853f;">  and with each line (including the last)</span>
<span style="color: #cd853f;">  terminated by a newline. </span><span style="color: #cd853f;">*/</span>
<span style="color: #20b2aa; font-weight: bold;">for</span> (i = 0; i &lt; n; i++)
  printf(<span style="color: #ffa07a;">"%6d%c"</span>, a[i], (i%10==9 || i==n-1) ? <span style="color: #ffa07a;">'\n'</span> : <span style="color: #ffa07a;">' '</span>);


printf(<span style="color: #ffa07a;">"You have %d items%s.\n"</span>, n, n==1 ? <span style="color: #ffa07a;">""</span> : <span style="color: #ffa07a;">"s"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-org65c4a1a" class="outline-3">
<h3 id="org65c4a1a"><span class="section-number-3">2.12</span> Precedence and Order of Evaluation</h3>
<div class="outline-text-3" id="text-2-12">
<p>
PRECEDENCE AND ASSOCIATIVITY OF OPERATORS:<br />
</p>


<div class="figure">
<p><img src="pics/precedence-and-associativity-of-operators.png" alt="precedence-and-associativity-of-operators.png" /><br />
</p>
</div>


<ul class="org-ul">
<li>Operators on the same line have the same precedence.<br /></li>
<li>Rows are in order of decreasing precedence.<br /></li>
<li>The "operator" () refers to function call.<br /></li>
<li>The operator -&gt; and . are used to access members of structures<br /></li>
<li>* (indirection through a pointer)<br /></li>
<li>&amp; (address of an object)<br /></li>
<li>Unary <code>&amp; + -</code> and <code>*</code> have higher precedence than the binary forms.<br /></li>
</ul>



<p>
C, like most languages, does not specify the order in which the operands of an operator are evaluated. (The exceptions are &amp;&amp;, ||, ?: and ','.)<br />
</p>

<hr />
<p>
For example:<br />
</p>
<div class="org-src-container">
<pre class="src src-C">x = f() + g();
</pre>
</div>
<p>
<code>f</code> may be evaluated before <code>g</code> or vice versa; thus if either <code>f</code> or <code>g</code> alters a variable on which the other depends, <code>x</code> can depend on the order of evaluation. Intermediate results can be stored in temporary variables to ensure a particular sequence.<br />
</p>
<hr />

<p>
Similary, the order in which function arguments are evaluated is not specified.<br />
</p>

<hr />
<div class="org-src-container">
<pre class="src src-C">printf(<span style="color: #ffa07a;">"%d %d\n"</span>, ++n, power(2, n)); <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">WRONG </span><span style="color: #cd853f;">*/</span>
</pre>
</div>
<p>
can produce different results with different compilers, depending on whether <code>n</code> is incremented before <code>power</code> is called. The solution, of course, is to write<br />
</p>
<div class="org-src-container">
<pre class="src src-C">++n;
printf(<span style="color: #ffa07a;">"%d %d\n"</span>, n, power(2, n));
</pre>
</div>
<hr />

<p>
Function calls, nested assignment statements, and increment and decrement operators cause ``side effects'' - some variable is changed as a by-product of the evaluation of an expression. In any expression involving side effects, there can be subtle dependencies on the order in which variables taking part in the expression are updated.<br />
</p>


<p>
The moral is that writing code that depends on order of evaluation is a bad programming practice in any language. Naturally, it is necessary to know what things to avoid, but if you don't know <b>how</b> they are done on various machines, you won't be tempted to take advantage of a particular implementation.<br />
</p>
</div>
</div>
</div>



<div id="outline-container-org1afdd09" class="outline-2">
<h2 id="org1afdd09"><span class="section-number-2">3</span> Control Flow</h2>
<div class="outline-text-2" id="text-3">
<p>
The control-flow of a language specify the order in which computations are performed.<br />
</p>
</div>

<div id="outline-container-orga0beb32" class="outline-3">
<h3 id="orga0beb32"><span class="section-number-3">3.1</span> Statements and Blocks</h3>
<div class="outline-text-3" id="text-3-1">
<p>
An expression becomes a <b>statement</b> when it is followed by a semicolon, as in<br />
</p>
<div class="org-src-container">
<pre class="src src-C">x = 0;
i++;
printf(...);
</pre>
</div>
<p>
In C, the semicolon is a statement terminator.<br />
</p>

<p>
Braces { and } are used to group declarations and statements together into a <b>compound statement</b>, or <b>block</b>, so that they are syntactically equivalent to a single statement. There is no semicolon after the right brace that ends a block.<br />
</p>
</div>
</div>


<div id="outline-container-org63f3afc" class="outline-3">
<h3 id="org63f3afc"><span class="section-number-3">3.2</span> If-Else</h3>
<div class="outline-text-3" id="text-3-2">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">if</span> (expression)
    statement1
<span style="color: #20b2aa; font-weight: bold;">else</span>
    statement2
</pre>
</div>

<p>
Because the <code>else</code> part of an <code>if-else</code> is optional,there is an ambiguity when an else <code>if</code> omitted from a nested if sequence. This is resolved by associating the <code>else</code> with the closest previous <code>else</code>-less <code>if</code>.<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">if</span> (n &gt; 0)
    <span style="color: #20b2aa; font-weight: bold;">if</span> (a &gt; b)
        z = a;
    <span style="color: #20b2aa; font-weight: bold;">else</span>
        z = b;
</pre>
</div>
<p>
If that isn't what you want, braces must be used to force the proper association:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">if</span> (n &gt; 0) {
    <span style="color: #20b2aa; font-weight: bold;">if</span> (a &gt; b)
        z = a;
}
<span style="color: #20b2aa; font-weight: bold;">else</span>
    z = b;
</pre>
</div>
<p>
it's a good idea to use braces when there are nested <code>if</code> s.<br />
</p>
</div>
</div>

<div id="outline-container-orgcbea9da" class="outline-3">
<h3 id="orgcbea9da"><span class="section-number-3">3.3</span> Else-If</h3>
<div class="outline-text-3" id="text-3-3">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">if</span> (expression)
    statement
<span style="color: #20b2aa; font-weight: bold;">else</span> <span style="color: #20b2aa; font-weight: bold;">if</span> (expression)
    statement
<span style="color: #20b2aa; font-weight: bold;">else</span> <span style="color: #20b2aa; font-weight: bold;">if</span> (expression)
    statement
<span style="color: #20b2aa; font-weight: bold;">else</span>
    statement
</pre>
</div>

<p>
The expressions are evaluated in order; if an expression is true, the statement associated with it is executed, and this terminates the whole chain. The last <code>else</code> part handles the "none of the above" or default case where none of the other conditions is satisfied.<br />
</p>
</div>
</div>


<div id="outline-container-org6648661" class="outline-3">
<h3 id="org6648661"><span class="section-number-3">3.4</span> Switch</h3>
<div class="outline-text-3" id="text-3-4">
<p>
The <code>switch</code> statement is a multi-way decision that tests whether an expression matches one of a number of <b>constant</b> integer values, and branches accordingly.<br />
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">switch</span> (expression) 
    {
        <span style="color: #20b2aa; font-weight: bold;">case</span> <span style="color: #20b2aa; font-weight: bold;">const</span>-expr: statements
        <span style="color: #20b2aa; font-weight: bold;">case</span> <span style="color: #20b2aa; font-weight: bold;">const</span>-expr: statements
        defalt: statements
    }
</pre>
</div>

<p>
Each case is labeled by one or more integer-valued constants or constant expressions. If a case matches the expression value, execution starts at that case. All case expressions must be different. The case labeled <code>default</code> is executed if none of the other cases are satisfied. A <code>default</code> is optional; if it isn't there and if none of the cases match, no action at all takes place. Cases and the default clause can occur in any order.<br />
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">main</span>() <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">count digits, white space, others </span><span style="color: #cd853f;">*/</span>
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">c</span>, <span style="color: #9acd32;">i</span>, <span style="color: #9acd32;">nwhite</span>, <span style="color: #9acd32;">nother</span>, <span style="color: #9acd32;">ndigit</span>[10];

  nwhite = nother = 0;
  <span style="color: #20b2aa; font-weight: bold;">for</span> (i = 0; i &lt; 10; i++)
    ndigit[i] = 0;

  <span style="color: #20b2aa; font-weight: bold;">while</span> ((c = getchar()) != EOF)
    {
      <span style="color: #20b2aa; font-weight: bold;">switch</span> (c)
        {
        <span style="color: #20b2aa; font-weight: bold;">case</span> <span style="color: #ffa07a;">'0'</span>: <span style="color: #20b2aa; font-weight: bold;">case</span> <span style="color: #ffa07a;">'1'</span>: <span style="color: #20b2aa; font-weight: bold;">case</span> <span style="color: #ffa07a;">'2'</span>: <span style="color: #20b2aa; font-weight: bold;">case</span> <span style="color: #ffa07a;">'3'</span>: <span style="color: #20b2aa; font-weight: bold;">case</span> <span style="color: #ffa07a;">'4'</span>: <span style="color: #20b2aa; font-weight: bold;">case</span> <span style="color: #ffa07a;">'5'</span>: <span style="color: #20b2aa; font-weight: bold;">case</span> <span style="color: #ffa07a;">'6'</span>: <span style="color: #20b2aa; font-weight: bold;">case</span> <span style="color: #ffa07a;">'7'</span>: <span style="color: #20b2aa; font-weight: bold;">case</span> <span style="color: #ffa07a;">'8'</span>: <span style="color: #20b2aa; font-weight: bold;">case</span> <span style="color: #ffa07a;">'9'</span>:
          ndigit[c-<span style="color: #ffa07a;">'0'</span>]++;
          <span style="color: #20b2aa; font-weight: bold;">break</span>;
        <span style="color: #20b2aa; font-weight: bold;">case</span> <span style="color: #ffa07a;">' '</span>:
        <span style="color: #20b2aa; font-weight: bold;">case</span> <span style="color: #ffa07a;">'\n'</span>:
        <span style="color: #20b2aa; font-weight: bold;">case</span> <span style="color: #ffa07a;">'\t'</span>:
          nwhite++;
          <span style="color: #20b2aa; font-weight: bold;">break</span>;
        <span style="color: #20b2aa; font-weight: bold;">default</span>:
          nother++;
          <span style="color: #20b2aa; font-weight: bold;">break</span>;
        }
    }

  printf(<span style="color: #ffa07a;">"digits ="</span>);
  <span style="color: #20b2aa; font-weight: bold;">for</span> (i = 0; i &lt; 10; i++)
    printf(<span style="color: #ffa07a;">" %d"</span>, ndigit[i]);
  printf(<span style="color: #ffa07a;">", white space = %d, other = %d\n"</span>, nwhite, nother);

  <span style="color: #20b2aa; font-weight: bold;">return</span> 0;
}

</pre>
</div>

<p>
The <code>break</code> statement causes an immediate exit from the <code>switch</code>. Because cases serve just as labels, after the code for one case is done, execution <b>falls through</b> to the next unless you take explicit action to escape. <code>break</code> and <code>return</code> are the most common ways to leave a switch.<br />
</p>


<p>
Falling through cases is a mixed blessing. On the positive side, it allows several cases to be attached to a single action. But it also implies that normally each case must end with a <code>break</code> to prevent falling through to the next. Falling through from one case to another is not robust, being prone to disintegration when the program is modified. With the exception of multiple labels for a single computation, fall-throughs should be used <b>sparingly, and commented</b>.<br />
</p>
</div>
</div>

<div id="outline-container-org0919cef" class="outline-3">
<h3 id="org0919cef"><span class="section-number-3">3.5</span> Loops - While and For</h3>
<div class="outline-text-3" id="text-3-5">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">while</span> (expression)
    statement
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">for</span> (expr1; expr2; expr3)
    <span style="color: #9370db;">statement</span>

<span style="color: #cd853f;">// </span><span style="color: #cd853f;">is equivalent to</span>
<span style="color: #9acd32;">expr1</span>;
<span style="color: #20b2aa; font-weight: bold;">while</span> (expr2)
    {
        <span style="color: #9370db;">statement</span>
        <span style="color: #9acd32;">expr3</span>;
    }
</pre>
</div>

<p>
Any of the three parts can be ommited, although the semicolons must retain. If <code>expr1</code> or <code>expr3</code> is omitted, ti is simply dropped from the expansion. If the test, <code>expr2</code> is not present, it is taken as permanently true, so<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">for</span> (;;) 
    {
        ...
    }
</pre>
</div>
<p>
is an "infinite" loop, presumably to be broken by other means, such as a <code>break</code> or <code>return</code>.<br />
</p>



<p>
Whether to use while or for is largely a matter of personal preference.<br />
When there is no initialization or re-innitialization, the <code>while</code> is most natural.<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">while</span> ((c = getchar()) == <span style="color: #ffa07a;">' '</span> || c == <span style="color: #ffa07a;">'\n'</span> || c == <span style="color: #ffa07a;">'\t'</span>)
    ;  <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">skip while space characters </span><span style="color: #cd853f;">*/</span>
</pre>
</div>
<p>
The for is preferable when there is a simple initialization and increment since it keeps the loop control statements close together and visible at the top of the loop.<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">for</span> (i = 0; i &lt; n; i++)
    ....
</pre>
</div>


<p>
The final C operator is the comma ",". A pair of expressions separated by a comma is evaluated left to right, and the type and value of the result are the type and value of the right operand.<br />
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">reverse: reverse string s in place </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">void</span> <span style="color: #00ff7f;">reverse</span>(<span style="color: #9370db;">char</span> <span style="color: #9acd32;">s</span>[])
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">c</span>, <span style="color: #9acd32;">i</span>, <span style="color: #9acd32;">j</span>;

  <span style="color: #20b2aa; font-weight: bold;">for</span> (i = 0; j = strlen(s)-1; i &lt; j; i++, j--)
    {
      c = s[i];
      s[i] = s[j];
      s[j] = c;
    }
}

</pre>
</div>
<pre class="example">
The comma that separate function arguments, variables in declarations, etc.,
are not comma operators, and do not guarantee the left to right evaluation.
</pre>

<p>
Comma operators should be used sparingly. The most suitable uses are for constructs strongly related to each other, as in the <code>for</code> loop in reverse, and in macros where a multistep computation has to be a single expression.<br />
</p>
</div>
</div>


<div id="outline-container-org95a7ee8" class="outline-3">
<h3 id="org95a7ee8"><span class="section-number-3">3.6</span> Loops - Do-While</h3>
<div class="outline-text-3" id="text-3-6">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">do</span>
    statement
<span style="color: #20b2aa; font-weight: bold;">while</span> (expression)
</pre>
</div>

<p>
The statement is executed, then expression is evaluated. If it is true, statement is evaluated again, and so on.<br />
</p>
</div>
</div>

<div id="outline-container-org322e207" class="outline-3">
<h3 id="org322e207"><span class="section-number-3">3.7</span> Break and Continue</h3>
<div class="outline-text-3" id="text-3-7">
<p>
The <code>break</code> statement provides an early exit from <code>for, while</code>, and <code>do</code>, just as from <code>switch</code>. A <code>break</code> causes the innermost enclosing loop or <code>switch</code> to be exited immediately.<br />
</p>

<p>
The <code>continue</code> statement causes the next iteration of the enclosing <code>for, while</code> or <code>do</code> loop to begin. In the <code>while</code> and <code>do</code>, this means that the test part is executed immediately; in the <code>for</code>, control passes to the increment step. The <code>continue</code> statement applies only to loops, not to <code>switch</code>. A <code>continue</code> inside a <code>switch</code> inside a loop causes the next loop iteration.<br />
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">for</span> (i = 0; i &lt; n; i++)
    <span style="color: #20b2aa; font-weight: bold;">if</span> (a[i] &lt; 0)  <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">skip negative elements </span><span style="color: #cd853f;">*/</span>
        <span style="color: #20b2aa; font-weight: bold;">continue</span>;
    ... <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">do positive elements </span><span style="color: #cd853f;">*/</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-org9602626" class="outline-3">
<h3 id="org9602626"><span class="section-number-3">3.8</span> Goto and labels</h3>
<div class="outline-text-3" id="text-3-8">
<p>
C provides the infinitely-abusable <code>goto</code> statement, and labels to branch to. Formally, the <code>goto</code> statement is never necessary, and in practice it is almost always easy to write code without it.<br />
</p>

<p>
Nevertheless, there are a few situations where <code>goto</code> may find a place. The most common is to abandon processing in some deeply nested structure, such as breaking out of two or more loops at once. The <code>break</code> statement cannot be used directly since it only exits from the innermost loop.<br />
</p>


<div class="org-src-container">
<pre class="src src-C">    <span style="color: #20b2aa; font-weight: bold;">for</span> (...)
        <span style="color: #20b2aa; font-weight: bold;">for</span> (...) {
            ...
            <span style="color: #20b2aa; font-weight: bold;">if</span> (disaster)
                <span style="color: #20b2aa; font-weight: bold;">goto</span> <span style="color: #1e90ff;">error</span>;
        }
    ...
error:
    <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">clean up the mess </span><span style="color: #cd853f;">*/</span>
</pre>
</div>
<p>
This organization is handy if the error-handling code is non-trivial, and if errors can occurs in several places.<br />
</p>

<p>
A <b>lable</b> has the same form as a variable name, and is followed by a colon. It can be attached to any statement in the same function as the <code>goto</code>. The scope of a label is the entire function.<br />
</p>

<hr />
<div class="org-src-container">
<pre class="src src-C">  <span style="color: #20b2aa; font-weight: bold;">for</span> (i = 0; i &lt; n; i++)
    <span style="color: #20b2aa; font-weight: bold;">for</span> (j = 0; j &lt; m; j++)
      <span style="color: #20b2aa; font-weight: bold;">if</span> (a[i] == b[i])
        <span style="color: #20b2aa; font-weight: bold;">goto</span> <span style="color: #1e90ff;">found</span>;
  <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">didn't find any commen element </span><span style="color: #cd853f;">*/</span>

<span style="color: #1e90ff;">found</span>:
<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">got one: a[i] == b[j] </span><span style="color: #cd853f;">*/</span>

</pre>
</div>

<p>
Code involving a <code>goto</code> can always be written without one, though perhaps at the price of some repeated tests or an extra variable.<br />
</p>

<div class="org-src-container">
<pre class="src src-C">found = 0;
<span style="color: #20b2aa; font-weight: bold;">for</span> (i = 0; i &lt; n &amp;&amp; !found; i++)
  <span style="color: #20b2aa; font-weight: bold;">for</span> (j = 0; j &lt; m &amp;&amp; !found; j++)
    <span style="color: #20b2aa; font-weight: bold;">if</span> (a[i] == b[j])
      found = 1;

<span style="color: #20b2aa; font-weight: bold;">if</span> (found)
  <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">got one: a[i-1] == b[j-1] </span><span style="color: #cd853f;">*/</span>
  ...
<span style="color: #20b2aa; font-weight: bold;">else</span>
  <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">didn't find any common element </span><span style="color: #cd853f;">*/</span>
  ...

</pre>
</div>
<hr />

<p>
With a few exceptions like those cited here, code that relies on <code>goto</code> statements is generally harder to understand and to maintain than code without <code>goto</code>. <code>goto</code> statements should be used rarely, if at all.<br />
</p>

<pre class="example">
Maybe used in operating system develepment.
</pre>
</div>
</div>
</div>


<div id="outline-container-org27a52d8" class="outline-2">
<h2 id="org27a52d8"><span class="section-number-2">4</span> Functions and Program Structure</h2>
<div class="outline-text-2" id="text-4">
<p>
Functions break large computing tasks into smaller ones, and enable people to build on what others have done instead of starting over from scratch. Appropriate functions hide details of operation from parts of the program that don't need to know about them, thus clarifying the whole, and easing the pain of making changes.<br />
</p>
</div>

<div id="outline-container-orgf315de9" class="outline-3">
<h3 id="orgf315de9"><span class="section-number-3">4.1</span> Basics of Functions</h3>
<div class="outline-text-3" id="text-4-1">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #cd853f;">/* </span>
<span style="color: #cd853f;">while (there's another line)</span>
<span style="color: #cd853f;">     if (the line contains the pattern)</span>
<span style="color: #cd853f;">       print it </span>
<span style="color: #cd853f;">*/</span>

<span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">MAXLINE</span> 1000            <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">maximum input line length </span><span style="color: #cd853f;">*/</span>

<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">getline</span>(<span style="color: #9370db;">char</span> <span style="color: #9acd32;">line</span>[], <span style="color: #9370db;">int</span> <span style="color: #9acd32;">max</span>);
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">strindex</span>(<span style="color: #9370db;">char</span> <span style="color: #9acd32;">source</span>[], <span style="color: #9370db;">char</span> <span style="color: #9acd32;">searchfor</span>[]);

<span style="color: #9370db;">char</span> <span style="color: #9acd32;">pattern</span>[] = <span style="color: #ffa07a;">"ould"</span>;        <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">pattern to search for </span><span style="color: #cd853f;">*/</span>

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">find all lines matching pattern </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">main</span>() {
  <span style="color: #9370db;">char</span> <span style="color: #9acd32;">line</span>[MAXLINE];
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">found</span> = 0;

  <span style="color: #20b2aa; font-weight: bold;">while</span> (getline(line, MAXLINE) &gt; 0)
    <span style="color: #20b2aa; font-weight: bold;">if</span> (strindex(line, pattern) &gt;= 0) {
      printf(<span style="color: #ffa07a;">"%s"</span>, line);
      found++;
    }
  <span style="color: #20b2aa; font-weight: bold;">return</span> found;
}

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">getline: get line into s, return length </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">getline</span>(<span style="color: #9370db;">char</span> <span style="color: #9acd32;">s</span>[], <span style="color: #9370db;">int</span> <span style="color: #9acd32;">lim</span>) {
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">c</span>, <span style="color: #9acd32;">i</span>;

  i = 0;
  <span style="color: #20b2aa; font-weight: bold;">while</span> (--lim &gt; 0 &amp;&amp; (c = getchar()) != EOF &amp;&amp; c != <span style="color: #ffa07a;">'\n'</span>)
    s[i++] = c;

  <span style="color: #20b2aa; font-weight: bold;">if</span> (c == <span style="color: #ffa07a;">'\n'</span>)
    s[i++] = c;
  s[i] = <span style="color: #ffa07a;">'\0'</span>;

  <span style="color: #20b2aa; font-weight: bold;">return</span> i;
}

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">strindex: return index of t in s, -1 if none </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">strindex</span>(<span style="color: #9370db;">char</span> <span style="color: #9acd32;">s</span>[], <span style="color: #9370db;">char</span> <span style="color: #9acd32;">t</span>[]) {
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">i</span>, <span style="color: #9acd32;">j</span>, <span style="color: #9acd32;">k</span>;

  <span style="color: #20b2aa; font-weight: bold;">for</span> (i = 0; s[i] != <span style="color: #ffa07a;">'\0'</span>; i++) {
    <span style="color: #20b2aa; font-weight: bold;">for</span> (j = i, k = 0; t[k] != <span style="color: #ffa07a;">'\0'</span> &amp;&amp; s[j] == t[k]; j++, k++)
      ;
    <span style="color: #20b2aa; font-weight: bold;">if</span> (k &gt; 0 &amp;&amp; t[k] == <span style="color: #ffa07a;">'\0'</span>)  <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">whole pattern matched </span><span style="color: #cd853f;">*/</span>
      <span style="color: #20b2aa; font-weight: bold;">return</span> i;
  }

  <span style="color: #20b2aa; font-weight: bold;">return</span> -1;
}

</pre>
</div>

<p>
Each function definition as the form<br />
</p>
<pre class="example">
return-type function-name(argument declarations)
{
    declarations and statements
}
</pre>

<p>
Various parts may be absent; a minimal function is<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00ff7f;">dummy</span>() {}
</pre>
</div>
<p>
which does nothing and returns nothing. If the return type is omitted, int is assumed.<br />
</p>


<p>
A program is just a set of definitions and functions. Communication between the functions is by arguments and values returned by the functions, and through external variables. The functions can occur in any order in the source file, and the source program can be split into multiple files, so long as no function is split.<br />
</p>

<hr />
<p>
The mechanics of how to compile and load a C program that resides on multiple source files vary from one system to the next. On the UNIX system, for example, the <code>cc</code> command does the job.<br />
</p>

<p>
Suppose that the three functions are stored in three files called main.c, getline.c, and strindex.c.<br />
</p>

<div class="org-src-container">
<pre class="src src-sh">cc main.c getline.c strindex.c
</pre>
</div>
<hr />
</div>
</div>

<div id="outline-container-orgbf10746" class="outline-3">
<h3 id="orgbf10746"><span class="section-number-3">4.2</span> Functions Returning Non-integers</h3>
<div class="outline-text-3" id="text-4-2">
<ol class="org-ol">
<li>The function itself must declare the type of value it returns.<br /></li>
<li>The calling routine most know the function returns a non-int value. (One way to ensure this is to declare the function explicitly in the calling routine.)<br /></li>
</ol>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #cd853f;">/* </span><span style="color: #cd853f;">stdlib.h includes an atof </span><span style="color: #cd853f;">*/</span>
<span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;ctype.h&gt;</span>

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">atof: convert string s to double </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">double</span> <span style="color: #00ff7f;">atof</span>(<span style="color: #9370db;">char</span> <span style="color: #9acd32;">s</span>[]) {
  <span style="color: #9370db;">double</span> <span style="color: #9acd32;">val</span>, <span style="color: #9acd32;">power</span>;
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">i</span>, <span style="color: #9acd32;">sign</span>;

  <span style="color: #20b2aa; font-weight: bold;">for</span> (i = 0; isspace(s[i]); i++) <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">skip white space </span><span style="color: #cd853f;">*/</span>
    ;

  sign = (s[i] == <span style="color: #ffa07a;">'-'</span>) ? -1 : 1;
  <span style="color: #20b2aa; font-weight: bold;">if</span> (s[i] == <span style="color: #ffa07a;">'+'</span> || s[i] == <span style="color: #ffa07a;">'-'</span>) <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">skip sign </span><span style="color: #cd853f;">*/</span>
    i++;

  <span style="color: #20b2aa; font-weight: bold;">for</span> (val = 0.0; isdigit(s[i]); i++)
    val = 10.0 * val + (s[i] - <span style="color: #ffa07a;">'0'</span>);

  <span style="color: #20b2aa; font-weight: bold;">if</span> (s[i] == <span style="color: #ffa07a;">'.'</span>)
    i++;

  <span style="color: #20b2aa; font-weight: bold;">for</span> (power = 1.0; isdigit(s[i]); i++) {
    val = 10.0 * val + (s[i] - <span style="color: #ffa07a;">'0'</span>);
    power *= 10;
  }

  <span style="color: #20b2aa; font-weight: bold;">return</span> sign * val / power;
}
</pre>
</div>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">MAXLINE</span> 1000

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">rudimentary calculator </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">main</span>() {
  <span style="color: #9370db;">double</span> <span style="color: #9acd32;">sum</span>, <span style="color: #00ff7f;">atof</span>(<span style="color: #9370db;">char</span> []);
  <span style="color: #9370db;">char</span> <span style="color: #9acd32;">line</span>[MAXLINE];
  <span style="color: #9370db;">int</span> <span style="color: #00ff7f;">getline</span>(<span style="color: #9370db;">char</span> <span style="color: #9acd32;">line</span>[], <span style="color: #9370db;">int</span> <span style="color: #9acd32;">max</span>);

  sum = 0;
  <span style="color: #20b2aa; font-weight: bold;">while</span> (getline(line, MAXLINE) &gt; )
    printf(<span style="color: #ffa07a;">"%\tg\n"</span>, sum += atof(line));
  <span style="color: #20b2aa; font-weight: bold;">return</span> 0;
}

</pre>
</div>


<p>
The function <code>atof</code> must be declared and defined consistently. If <code>atof</code> itself and the call to it in main have inconsistent types in the same source file, the error will be detected by the compiler. But if (as is more likely) <code>atof</code> were compiled separately, the mismatch would not be detected, <code>atof</code> would return a <code>double</code> that <code>main</code> would treat as an <code>int</code>, and meaningless answers would result.<br />
</p>


<p>
The reason a mismatch can happen is that if there is no function prototype, a function is implicitly declared by its first appearance in an expression, such as<br />
</p>
<div class="org-src-container">
<pre class="src src-C">sum += atof(line)
</pre>
</div>
<p>
If a name that has not been previously declared occurs in an expression and is followed by a left parentheses, it is declared by context to be a function name, the function is assumed to return an <code>int</code>, and nothing is assumed about its arguments.<br />
</p>

<p>
NOTE:<br />
This special meaning of the empty argument list is intended to permit older C programs to compile with new compilers. But it's a bad idea to use it with new C programs. If the function takes arguments, declare them; if it takes no arguments, use <code>void</code>.<br />
</p>
</div>
</div>


<div id="outline-container-orga12808a" class="outline-3">
<h3 id="orga12808a"><span class="section-number-3">4.3</span> External Variables</h3>
<div class="outline-text-3" id="text-4-3">
<p>
A C program consists of a set of external objects, which are either variables or functions. The adjective ``external'' is used in contrast to ``internal'', which describes the arguments and variables defined inside functions. External variables are defined outside of any function, and are thus potentionally available to many functions. Functions themselves are always external, because C does not allow functions to be defined inside other functions.<br />
</p>

<p>
Because external variables are globally accessible, they provide an alternative to function arguments and return values for communicating data between functions.<br />
</p>

<p>
If a large number of variables must be shared among functions, external variables are more convenient and efficient than long argument lists. However, this reasoning should be applied with some caution, for it can have a bad effect on program structure, and lead to programs with too many data connections between functions.<br />
</p>


<p>
External variables are also useful because of their greater scope and lifetime. Automatic variables are internal to a function; they come into existence when the function is entered, and disappear when it is left. External variables, on the other hand, are permanent, so they can retain values from one function invocation to the next.<br />
</p>
</div>
</div>

<div id="outline-container-orgd82a4ea" class="outline-3">
<h3 id="orgd82a4ea"><span class="section-number-3">4.4</span> Scope Rules</h3>
<div class="outline-text-3" id="text-4-4">
<p>
The functions and external variables that make up a C program need not all be compiled at the same time; the source text of the program may be kept in several files, and previously compiled routines may be loaded from libraries.<br />
</p>

<p>
Questions:<br />
</p>
<ul class="org-ul">
<li>How are declarations written so that variables are properly declared during compilation?<br /></li>
<li>How are declarations arranged so that all the pieces will be properly connected when the program is loaded?<br /></li>
<li>How are declarations organized so there is only one copy?<br /></li>
<li>How are external variables initialzed?<br /></li>
</ul>

<p>
The <b>scope</b> of a name is the part of the program within which the name can be used.<br />
</p>

<p>
<b>For an automatic variable declared at the beginning of a function, the scope is the function in which the name is declared.</b><br />
<b>The scope of an external variable or a function lasts from the point at which it is declared to the end of the file being compiled.</b><br />
<b>If an external variable is to be referred to before it is defined, or if it is defined in a different source file from the one where it is being used, then an extern declaration is mandatory.</b><br />
</p>

<hr />
<p>
<b>declaration vs definition:</b><br />
A declaration announces the properties of a variable (primarily its type); a definition also causes storage to be set aside.<br />
</p>

<p>
If the lines<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #9acd32;">sp</span>;
<span style="color: #9370db;">double</span> <span style="color: #9acd32;">val</span>[MAXVAL];
</pre>
</div>
<p>
appear outside of any function, they <b>define</b> the external variables <code>sp</code> and <code>val</code>, cause storage to be set aside, and also serve as the declaration for the rest of that source file.<br />
</p>

<p>
On the hand hand, the lines<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">extern</span> <span style="color: #9370db;">int</span> <span style="color: #9acd32;">sp</span>;
<span style="color: #20b2aa; font-weight: bold;">extern</span> <span style="color: #9370db;">double</span> <span style="color: #9acd32;">val</span>[];
</pre>
</div>
<p>
<b>declare</b> for the rest of the source file that <code>sp</code> is an <code>int</code> and that <code>val</code> is a <code>double</code> array (whose size is determined elsewhere), but they do not create the variable or reserve storage for them.<br />
</p>

<p>
There must be only <b>one definition</b> of an external variable among all the files that make up the source program; other files may conatain <code>extern</code> declarations to access it. Array size must be specified with the definition, but are optional with an <code>extern</code> declaration.<br />
</p>

<p>
Initialization of a external variable goes only with the definition.<br />
</p>
<hr />
</div>
</div>

<div id="outline-container-org8e43e06" class="outline-3">
<h3 id="org8e43e06"><span class="section-number-3">4.5</span> Header Files</h3>
<div class="outline-text-3" id="text-4-5">
<p>
As the program getting bigger and bigger, the program will goes into serveral source files. There is one thing to worry about - the definitions and declarations shared among files. As much as possible, we want to centralize this, so that there is only one copy to get and keep right as the program evolves. Accordingly, we will place this common material in a <b>header file</b>, which will be included as necessary.<br />
</p>


<p>
There is a tradeoff between the desire that each file have access only to the information it needs for its job and the practical reality that it is harder to maintain more header files. Up to some moderate program size, it is probably best to have one header file that contains everything that is to be shared between any two parts of the program. For a much larger program, more organization and more headers would be needed.<br />
</p>
</div>
</div>


<div id="outline-container-org43b4574" class="outline-3">
<h3 id="org43b4574"><span class="section-number-3">4.6</span> Static Variables</h3>
<div class="outline-text-3" id="text-4-6">
<p>
The <code>static</code> declaration, applied to an external variable or function, limits the scope of that object to the rest of the source file being compiled.<br />
</p>

<p>
Static storage is specified by prefixing the normal declaration with the word static. If the two routines and the two variables are compiled in one file, as in<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">static</span> <span style="color: #9370db;">char</span> <span style="color: #9acd32;">buf</span>[BUFSIZE]; <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">buffer for ungetch </span><span style="color: #cd853f;">*/</span> 
<span style="color: #20b2aa; font-weight: bold;">static</span> <span style="color: #9370db;">int</span> <span style="color: #9acd32;">bufp</span> = 0; <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">next free position in buf </span><span style="color: #cd853f;">*/</span>

<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">getch</span>(<span style="color: #9370db;">void</span>) { ... }

<span style="color: #9370db;">void</span> <span style="color: #00ff7f;">ungetch</span>(<span style="color: #9370db;">int</span> <span style="color: #9acd32;">c</span>) { ... }
</pre>
</div>
<p>
then no other routine will be able to access <code>buf</code> and <code>bufp</code>, and those names will not conflict with the same names in other files of the same program.<br />
</p>

<p>
The external <code>static</code> declaration is most often used for variables, but it can be applied to functions as well. Normally, function names are global, visible to any part of the entire program. If a function is declared <code>static</code>, however, its name is invisible outside of the file in which it is declared.<br />
</p>

<p>
The <code>static</code> declaration can also be applied to internal variables. Internal <code>static</code> variables are local to a particular function just as automatic variables are, but unlike automatics, they remain in existence rather than coming and going each time the function is activated. This means that internal <code>static</code> variables provide private, permanent storage within a single function.<br />
</p>
</div>
</div>

<div id="outline-container-orga9bc954" class="outline-3">
<h3 id="orga9bc954"><span class="section-number-3">4.7</span> Register Variables</h3>
<div class="outline-text-3" id="text-4-7">
<p>
A <code>register</code> declaration advises the compiler that the variable in question will be heavily used. The idea is that <code>register</code> variables are to be placed in machine registers, which may result in smaller and faster programs. But compilers are free to ignore the advice.<br />
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">register</span> <span style="color: #9370db;">int</span> <span style="color: #9acd32;">x</span>;
<span style="color: #20b2aa; font-weight: bold;">register</span> <span style="color: #9370db;">char</span> <span style="color: #9acd32;">c</span>;
</pre>
</div>

<p>
The register declaration can only be applied to automatic variables and to the formal parameters of a function.<br />
</p>
<div class="org-src-container">
<pre class="src src-C">f(<span style="color: #20b2aa; font-weight: bold;">register</span> <span style="color: #9370db;">unsigned</span> <span style="color: #9acd32;">m</span>, <span style="color: #20b2aa; font-weight: bold;">register</span> <span style="color: #9370db;">long</span> <span style="color: #9acd32;">n</span>)
{
    <span style="color: #20b2aa; font-weight: bold;">register</span> <span style="color: #9370db;">int</span> <span style="color: #9acd32;">i</span>;
    ...
}
</pre>
</div>


<p>
In practice, there are restrictions on register variables, reflecting the realities of underlying hardware. Only a few variables in each function may be kept in registers, and only certain types are allowed. It is not possible to take the address of a register variable, regardless of whether the variable is actually placed in a register. The specific restrictions on number and types of register variables vary from machine to machine.<br />
</p>
</div>
</div>


<div id="outline-container-org096d582" class="outline-3">
<h3 id="org096d582"><span class="section-number-3">4.8</span> Block Structure</h3>
<div class="outline-text-3" id="text-4-8">
<p>
C is not a block-strucutred language, because functions may not be define within other functions. On the other hand, variables can be defined in a block-strucutred fashion within a function.<br />
</p>

<p>
Declarations of variables (including initializations) may follow the left brace that introduces any compound statement, not just the one that begins a function. Variables declared in this way <b>hide</b> any identically named variables in outer blocks, and remain in existence until the matching right brace. For example, in<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">if</span> (n &gt; 0) {
    <span style="color: #9370db;">int</span> <span style="color: #9acd32;">i</span>; <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">declare a new i </span><span style="color: #cd853f;">*/</span>

    <span style="color: #20b2aa; font-weight: bold;">for</span> (i = 0; i &lt; n; i++)
        ...
}
</pre>
</div>
<p>
the scope of the variable <code>i</code> is the ``true'' branch of the <code>if</code>; this <code>i</code> is unrelated to any <code>i</code> outside the block.<br />
</p>


<p>
Automatic variables, including formal parameters, also <b>hide</b> external variables and functions of the same name.<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #9acd32;">x</span>;
<span style="color: #9370db;">int</span> <span style="color: #9acd32;">y</span>;

<span style="color: #00ff7f;">f</span>(<span style="color: #9370db;">double</span> <span style="color: #9acd32;">x</span>)
{
    <span style="color: #9370db;">double</span> <span style="color: #9acd32;">y</span>;
}
</pre>
</div>
<p>
then within the function <code>f</code>, occurrences of <code>x</code> refer to the parameter, which is a <code>double</code>; outside <code>f</code>, they refer to the external <code>int</code>.<br />
</p>
</div>
</div>

<div id="outline-container-orga559353" class="outline-3">
<h3 id="orga559353"><span class="section-number-3">4.9</span> Initialization</h3>
<div class="outline-text-3" id="text-4-9">
<p>
[defualt values]<br />
In the absence of explicit initialization, external and static variables are guaranteed to be initialized to zero; automatic and register variables have undefined (i.e., garbage) initial values.<br />
</p>


<p>
[permited expression]<br />
For external and static variables, the initializer must be a constant expression; the initialization is done once, conceptionally before the program begins execution. For automatic and register variables, the initializer is not restricted to being a constant: it may be any expression involving previously defined values, even function calls.<br />
</p>


<pre class="example">
Arithmetic types and pointer types are collectively called scalar types. 
Array and structure types are collectively called aggregate types.
</pre>


<p>
Scalar variables may be initialized when they are defined, by following the name with an equals sign and an expression:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #9acd32;">x</span> = 1;
<span style="color: #9370db;">char</span> <span style="color: #9acd32;">squota</span> = <span style="color: #ffa07a;">'\''</span>;
<span style="color: #9370db;">long</span> <span style="color: #9acd32;">day</span> = 1000L * 60L * 60L * 24L; <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">milliseconds/day </span><span style="color: #cd853f;">*/</span>
</pre>
</div>

<p>
An array may be initialized by following its declaration with a list of initializers enclosed in braces and separated by commas.<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #9acd32;">days</span>[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
</pre>
</div>
<p>
When the size of the array is omitted, the compiler will compute the length by counting the initializers, of which there are 12 in this case.<br />
</p>

<p>
If there are fewer initializers for an array than the specified size, the others will be zero for external, static and automatic variables. It is an error to have too many initializers. There is no way to specify repetition of an initializer, nor to initialize an element in the middle of an array without supplying all the preceding values as well.<br />
</p>


<p>
Character arrays are a special case of initialization; a string may be used instead of the braces and commas notation:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">char</span> <span style="color: #9acd32;">pattern</span> = <span style="color: #ffa07a;">"ould"</span>;
</pre>
</div>
<p>
is shorthand for the longer but equivalent<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">char</span> <span style="color: #9acd32;">pattern</span>[] = { <span style="color: #ffa07a;">'o'</span>, <span style="color: #ffa07a;">'u'</span>, <span style="color: #ffa07a;">'l'</span>, <span style="color: #ffa07a;">'d'</span>, <span style="color: #ffa07a;">'\0'</span> };
</pre>
</div>
</div>
</div>

<div id="outline-container-org58aa25e" class="outline-3">
<h3 id="org58aa25e"><span class="section-number-3">4.10</span> Recursion</h3>
<div class="outline-text-3" id="text-4-10">
<p>
Recursion may provide no saving in storage, since somewhere a stack of the values being processed must be maintained. Nor will it be faster. But recursive code is more compact, and often much easier to write and understand than the non-recursive equivalent. Recursion is especially convenient for recursively defined data structures like trees.<br />
</p>
</div>
</div>


<div id="outline-container-org069eeb3" class="outline-3">
<h3 id="org069eeb3"><span class="section-number-3">4.11</span> The C preprocessor</h3>
<div class="outline-text-3" id="text-4-11">
<p>
C provides certain language facilities by means of a <b>preprocessor</b>, which is conceptionally a separate first step in compilation.<br />
</p>
<dl class="org-dl">
<dt>#include</dt><dd>to include contents of a file during compilation<br /></dd>
<dt>#define</dt><dd>to replace a token by an arbitrary sequence of characters<br /></dd>
<dt>conditional compilation</dt><dd></dd>

<dt>macros with arguments</dt><dd></dd>
</dl>
</div>


<div id="outline-container-orgecfefc7" class="outline-4">
<h4 id="orgecfefc7"><span class="section-number-4">4.11.1</span> File Inclusion</h4>
<div class="outline-text-4" id="text-4-11-1">
<p>
File inclusion makes it easy to handle collections of #defines and declarations (among other things).<br />
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">"filename"</span>
<span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;filename&gt;</span>
</pre>
</div>
<p>
is replaced by the contents of the file <code>filename</code>. If the <code>filename</code> is quoted, searching for the file typically begins where the source program was found; if it is not found there, or if the name is enclosed in &lt; and &gt;, searching follows an implementation-defined rule to find the file.<br />
</p>

<p>
<code>#include</code> is the preferred way to tie the declarations together for a large program. It guarantees that all the source files will be supplied with the same definitions and variable declarations, and thus eliminates a particularly nasty kind of bug. Naturally, when an included file is changed, all files that depend on it must be recompiled.<br />
</p>
</div>
</div>

<div id="outline-container-orgd9ca570" class="outline-4">
<h4 id="orgd9ca570"><span class="section-number-4">4.11.2</span> Macro Substitution</h4>
<div class="outline-text-4" id="text-4-11-2">
<p>
A definition has the form<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">name</span> relacement_text
</pre>
</div>
<p>
It calls for a macro substitution of the simplest kind - subsequent occurrences of the token <code>name</code> will be replaced by the <code>replacement_text</code>. The name in a <code>#define</code> has the same form as a variable name; the replacement text is arbitrary. The scope of a name defined with <code>#define</code> is from its point of definition to the end of the source file being compiled.<br />
</p>

<p>
Any name may be defined with any replacement text. For example<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">forever</span> <span style="color: #20b2aa; font-weight: bold;">for</span> (;;)        <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">infinite loop </span><span style="color: #cd853f;">*/</span>
</pre>
</div>


<p>
It is also possible to define macros with arguments, so the replacement text can be different for different call of the macros.<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#define</span> <span style="color: #00ff7f;">max</span>(<span style="color: #9acd32;">A</span>, <span style="color: #9acd32;">B</span>)  ((A) &gt; (B) ? (A) : (B))
</pre>
</div>
<p>
This macro serve for any data type; there is no need for different kinds of <code>max</code> for different data types, as there would be with functions.<br />
</p>


<p>
If you examine the expansion of <code>max</code>, you will notice some pitfalls. The expressions are evaluated twice; this is bad if they involve side effects like increment operators or input and output.<br />
For instance<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00ff7f;">max</span>(i++, j++)                   <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">WRONG </span><span style="color: #cd853f;">*/</span>
</pre>
</div>
<p>
will increment the larger twice.<br />
</p>

<p>
Some care also has to be taken with parentheses to make sure the order of evaluation is perserved; consider what happens when the macro<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#define</span> <span style="color: #00ff7f;">square</span>(<span style="color: #9acd32;">x</span>)  x * x        <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">WRONG </span><span style="color: #cd853f;">*/</span>
</pre>
</div>
<p>
is invoked as <code>square(z+1)</code>.<br />
</p>
<div class="org-src-container">
<pre class="src src-C">z + 1 * z + 1
</pre>
</div>


<p>
Nonetheless, macros are valuable. One practical example comes from <code>&lt;stdio.h&gt;</code>, in which <code>getchar</code> and <code>putchar</code> are often defined as macros to avoid the <b>run-time overhead of a function call</b> per character processed. The functions in <code>&lt;ctype.h&gt;</code> are also usually implemented as macros.<br />
</p>


<p>
Names may be undefined with <code>#undef</code>, usually to ensure that a routine is really a function, not a macro:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#undef</span> getchar

<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">getchar</span>(<span style="color: #9370db;">void</span>) { ... }
</pre>
</div>


<p>
Formal parameters are not replaced within quoted strings. If however, a parameter name is preceded by a # in the replacement text, the combination will be expanded into a quoted string with the parameter replaced with the actual argument.<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#define</span> <span style="color: #00ff7f;">dprint</span>(<span style="color: #9acd32;">expr</span>)  printf(#expr <span style="color: #ffa07a;">" = %g\n"</span>, expr)
</pre>
</div>
<p>
When this is invoked, as in<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00ff7f;">dprint</span>(x/y)
</pre>
</div>
<p>
the macro is expanded into<br />
</p>
<div class="org-src-container">
<pre class="src src-C">printf(<span style="color: #ffa07a;">"x/y"</span> <span style="color: #ffa07a;">" = &amp;g\n"</span>, x/y);
</pre>
</div>
<p>
and the strings are concatenated, so the effect is<br />
</p>
<div class="org-src-container">
<pre class="src src-C">printf(<span style="color: #ffa07a;">"x/y = &amp;g\n"</span>, x/y);
</pre>
</div>
<p>
Within the acutual argument, each " is replace by a \" and each \ by \\, so the result is a legal string constant.<br />
</p>
</div>
</div>


<div id="outline-container-orgf621766" class="outline-4">
<h4 id="orgf621766"><span class="section-number-4">4.11.3</span> Conditional Inclusion</h4>
<div class="outline-text-4" id="text-4-11-3">
<p>
It is possible to control preprocessing itself with conditional statements that are evaluated during preprocessing. This provides a way to include code selectively, depending on the value of conditions evaluated during compilation.<br />
</p>

<p>
The <code>#if</code> line evaluates a constant integer expression (which may not include <code>sizeof</code>, casts, or <code>enum</code> constants). If the expression is non-zero, subsequent lines until an <code>#endif</code> or <code>#elif</code> or <code>#else</code> are included. The expression <code>defined(name)</code> in a <code>#if</code> is 1 if the <code>name</code> has been defined, and 0 otherwise.<br />
</p>

<hr />
<p>
For example, to make sure that the contents of a file <code>hdr.h</code> are included only once, the contents of the file are surrounded with a conditional like this:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#if</span> !<span style="color: #6495ed;">defined</span>(HDR)
<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">HDR</span>
<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">contents of hdr.h go here </span><span style="color: #cd853f;">*/</span>
<span style="color: #6495ed;">#endif</span>
</pre>
</div>
<p>
The first inclusion of <code>hdr.h</code> defines the name <code>HDR</code>; subsequent inclusions will find the name defined and skip down to the <code>#endif</code>.<br />
</p>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#if</span> SYSTEM == SYSV
<span style="color: #6495ed;">    #define</span> <span style="color: #9acd32;">HDR</span> <span style="color: #ffa07a;">"sysv.h"</span>
<span style="color: #6495ed;">#elif</span> SYSTEM == BSD
<span style="color: #6495ed;">    #define</span> <span style="color: #9acd32;">HDR</span> <span style="color: #ffa07a;">"bsd.h"</span>
<span style="color: #6495ed;">#elif</span> SYSTEM == MODOS
<span style="color: #6495ed;">    #define</span> <span style="color: #9acd32;">HDR</span> <span style="color: #ffa07a;">"modos.h"</span>
<span style="color: #6495ed;">#else</span>
<span style="color: #6495ed;">    #define</span> <span style="color: #9acd32;">HDR</span> <span style="color: #ffa07a;">"default.h"</span>
<span style="color: #6495ed;">#endif</span>
<span style="color: #6495ed;">#include</span> HDR
</pre>
</div>
<p>
This sequence tests the name <code>SYSTEM</code> to decide which version of a header to include.<br />
</p>


<p>
The <code>#ifdef</code> and <code>#ifndef</code> lines are spcialized form that test whether a name is defined.<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#if</span><span style="color: #6495ed;">n</span><span style="color: #6495ed;">def</span> HDR
<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">HDR</span>

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">contents of hdr.h go here </span><span style="color: #cd853f;">*/</span>

<span style="color: #6495ed;">#endif</span>
</pre>
</div>
<hr />
</div>
</div>
</div>
</div>

<div id="outline-container-org3c7f6e3" class="outline-2">
<h2 id="org3c7f6e3"><span class="section-number-2">5</span> Pointers and Arrays</h2>
<div class="outline-text-2" id="text-5">
<p>
A pointer is a <b>variable</b> than contains the <b>address</b> of a variable.<br />
</p>

<p>
Pointers are much used in C, partly because they are sometimes the only way to express a computation, and partly because they usually lead to more compact and efficient code than that can be obtained in other ways.<br />
</p>

<p>
Pointers and arrays are closely related.<br />
</p>
</div>

<div id="outline-container-org5fc3b28" class="outline-3">
<h3 id="org5fc3b28"><span class="section-number-3">5.1</span> Pointers and Addresses</h3>
<div class="outline-text-3" id="text-5-1">
<p>
A typical machine has an array of consecutively numbered or addressed memory cells that may be manipulated individually or in contiguous groups. One common situation is that any byte can be a <code>char</code>, a pair of one-byte cells can be treated as a <code>short</code> integer, and four adjacent bytes form a <code>long</code>. A pointer is a group of cells (often two or four) that can hold an address. So if <code>c</code> is a <code>char</code> and <code>p</code> is a pointer that points to it, we could represent the situation this way:<br />
</p>


<div class="figure">
<p><img src="pics/pointer.png" alt="pointer.png" /><br />
</p>
</div>

<p>
The unary operator <code>&amp;</code> gives the address of an object, so the statement<br />
</p>
<div class="org-src-container">
<pre class="src src-C">p = &amp;c;
</pre>
</div>
<p>
assigns the address of <code>c</code> to the variable <code>p</code>, and <code>p</code> is said to "point to" <code>c</code>. The <code>&amp;</code> operator only applies to <b>objects in memory</b>: variables and array elements. It cannot be applied to expressions, constants, or <code>register</code> variables.<br />
</p>

<p>
The unary operator <code>*</code> is the <b>indirection</b> or <b>dereferencing</b> operator; when applied to a pointer, it access the object the pointer points to.<br />
</p>

<hr />
<p>
Suppose that <code>x</code> and <code>y</code> are integers and <code>ip</code> is a pointer to <code>int</code>.<br />
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #9acd32;">x</span> = 1, <span style="color: #9acd32;">y</span> = 2, <span style="color: #9acd32;">z</span>[10];
<span style="color: #9370db;">int</span> *<span style="color: #9acd32;">ip</span>;                        <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">ip is a pointer to int </span><span style="color: #cd853f;">*/</span>

ip = &amp;x;                        <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">ip now points to x </span><span style="color: #cd853f;">*/</span>
y = *ip;                        <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">y is now 1 </span><span style="color: #cd853f;">*/</span>
*ip = 0;                        <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">x is now 0 </span><span style="color: #cd853f;">*/</span>
ip = &amp;z[0];                     <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">ip is now points to z[0] </span><span style="color: #cd853f;">*/</span>
</pre>
</div>

<p>
The declaration of the pointer <code>ip</code>,<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> *<span style="color: #9acd32;">ip</span>;
</pre>
</div>
<p>
is intended as a <b>mnemonic</b>; it says that <b>the expression <code>*ip</code> is an <code>int</code></b>. The syntax of the declaration for a variable mimics the syntax of expressions in which the variable might appear. This reasoning applies to function declaration as well.<br />
</p>

<p>
For example,<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">double</span> *<span style="color: #9acd32;">dp</span>, <span style="color: #00ff7f;">atof</span>(<span style="color: #9370db;">char</span> *);
</pre>
</div>
<p>
says that in an expression <code>*dp</code> and <code>atof(s)</code> have values of <code>double</code>, and that the argument of <code>atof</code> is a pointer to <code>char</code>.<br />
</p>

<p>
The parameter name are omitted, just as in<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #00ff7f;">getop</span>(<span style="color: #9370db;">char</span> []);
</pre>
</div>
<hr />

<p>
A pointer is constrained to point to a particular kine of object: every pointer points to a specific data type. (There is one exception: a "pointer to <code>void</code>" is used to hold any type of pointer but cannot be dereferenced itself.)<br />
</p>


<p>
The unary operator <code>*</code> and <code>&amp;</code> bind more tightly than arithmetic operators.<br />
</p>
<div class="org-src-container">
<pre class="src src-C">y = *ip + 1
</pre>
</div>
<p>
takes whatever <code>ip</code> points at, adds 1, and assign the result to <code>y</code>.<br />
</p>
<div class="org-src-container">
<pre class="src src-C">*ip += 1
</pre>
</div>
<p>
imcrements what <code>ip</code> points to, as do<br />
</p>
<div class="org-src-container">
<pre class="src src-C">++*ip
</pre>
</div>
<p>
and<br />
</p>
<div class="org-src-container">
<pre class="src src-C">(*ip)++
</pre>
</div>
<p>
The parentheses are necessary in this last example; without them, the expression would increment <code>ip</code> instead of what it points to, because unary operators line <code>*</code> and <code>++</code> associate <b>right to left</b>.<br />
</p>


<p>
Since pointers are variables, they can be used without dereferencing.<br />
For example, if <code>iq</code> is another pointer to <code>int</code>,<br />
</p>
<div class="org-src-container">
<pre class="src src-C">iq = ip
</pre>
</div>
<p>
copies the contents of <code>ip</code> into <code>iq</code>, thus making <code>iq</code> point to whatever <code>ip</code> pointed to.<br />
</p>
</div>
</div>




<div id="outline-container-org007e54a" class="outline-3">
<h3 id="org007e54a"><span class="section-number-3">5.2</span> Pointers and Function Arguments</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Since C passes arguments to functions by value, there is no direct way for the called function to alter a variable in the calling function.<br />
</p>

<hr />
<p>
For instance, a sorting routine might exchange two out-of-order arguments with a function called <code>swap</code>. It is not enough to write<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00ff7f;">swap</span> (a, b);
</pre>
</div>
<p>
where <code>swap</code> function is defined as<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">void</span> <span style="color: #00ff7f;">swap</span>(<span style="color: #9370db;">int</span> <span style="color: #9acd32;">x</span>, <span style="color: #9370db;">int</span> <span style="color: #9acd32;">y</span>)         <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">WRONG </span><span style="color: #cd853f;">*/</span>
{
    <span style="color: #9370db;">int</span> <span style="color: #9acd32;">temp</span>;

    temp = x;
    x = y;
    y = temp;
}
</pre>
</div>
<p>
Because of call by value, <code>swap</code> can't affect the arguments <code>a</code> and <code>b</code> in the routine that called it. The function above swaps <b>copies</b> of <code>a</code> and <code>b</code>.<br />
</p>

<p>
The way to obtain the desired effect is for the calling program to pass <b>pointers</b> to the values to be changed:<br />
</p>
<div class="org-src-container">
<pre class="src src-C">swap(&amp;a, &amp;b);
</pre>
</div>

<p>
Since the operator <code>&amp;</code> produces the address of a variable, <code>&amp;a</code> is a pointer to <code>a</code>. In <code>swap</code> itself, the parameters are declared as pointers, and the operands are accessed indirectly through them.<br />
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">void</span> <span style="color: #00ff7f;">swap</span>(<span style="color: #9370db;">int</span> *<span style="color: #9acd32;">xp</span>, <span style="color: #9370db;">int</span> *<span style="color: #9acd32;">yp</span>)     <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">interchange *xp and *yp </span><span style="color: #cd853f;">*/</span>
{
    <span style="color: #9370db;">int</span> <span style="color: #9acd32;">temp</span>;

    temp = *xp;
    *xp = *yp;
    *yp = temp;
}
</pre>
</div>
<hr />

<p>
Pointer arguments enable a function to access and change objects in the function that called it.<br />
</p>
</div>
</div>


<div id="outline-container-org731e7e2" class="outline-3">
<h3 id="org731e7e2"><span class="section-number-3">5.3</span> Pointers and Arrays</h3>
<div class="outline-text-3" id="text-5-3">
<p>
In C, there is a strong relationship between pointers and arrays, strong enough that pointers and arrays should be discussed simutaneously.<br />
</p>

<p>
[pointer arithmetic]<br />
If <code>pa</code> points to a particular element of an array, then by definition <code>pa+1</code> points to the next element, <code>pa+i</code> points to <code>i</code> elements after <code>pa</code>, and <code>pa-i</code> points to element before. These remarks are true regardless of the type or size of the variables in the array. The meaning of "adding 1 to a pointer", and by extension, all pointer arithmetic, is that <code>pa+1</code> points to the next <b>object</b>, and <code>pa+1</code> points to the i-th object beyond <code>pa</code>.<br />
</p>



<p>
The correspondence between indexing and pointer arithmetic is very close. <b>By definition, the value of a variable or expression of type array is the address of element zero of the array.</b> Thus after the assignment<br />
</p>
<div class="org-src-container">
<pre class="src src-C">pa = &amp;a[0];
</pre>
</div>
<p>
<code>pa</code> and <code>a</code> have identical values. Since the name of an array is a synonym for the location of the initial element, The assignment can also be written as<br />
</p>
<div class="org-src-container">
<pre class="src src-C">pa = a;
</pre>
</div>



<p>
A reference to <code>a[i]</code> can also be written as <code>*(a+i)</code>. <b>In evaluating <code>a[i]</code>, C converts it to <code>*(a+i)</code> immediately</b>; the two forms are equivalent. Applying the operator <code>&amp;</code> to both parts of this equivalence, it follows that <code>&amp;a[i]</code> and <code>a+i</code> are also identical: <code>a+i</code> is the address of the i-th element beyond <code>a</code>. As the other side of this coin, if <code>pa</code> is a pointer, expressions might use it with a subscript; <code>pa[i]</code> is identical to <code>*(pa+i)</code>. In short, an array-and-index expression is equivalent to one written as a pointer and offset.<br />
</p>



<p>
There is one difference between an array name and a pointer that must be kept in mind. A pointer is a <b>variable</b>, so <code>pa=a</code> and <code>pa++</code> are legal. But an array name is not a variable; constructions like <code>a=pa</code> and <code>a++</code> are illegal.<br />
</p>


<p>
[pass value]<br />
When an array name is passed to a function, what is passed is the location of the initial element. Within the called function, this argument is a local variable, and so an array name parameter is a pointer, that is, a variable containing an address.<br />
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #cd853f;">/* </span><span style="color: #cd853f;">strlen: return length of string s </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">strlen</span>(<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">s</span>)
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">n</span>;

  <span style="color: #20b2aa; font-weight: bold;">for</span> (n = 0; *s != <span style="color: #ffa07a;">'\0'</span>; s++)
    n++;
  <span style="color: #20b2aa; font-weight: bold;">return</span> n;
}
</pre>
</div>
<p>
Since <code>s</code> is a pointer (copied), incrementing it is perfectly legal; <code>s++</code> has no effect on the character string in the function that called <code>strlen</code>, but merely increments <code>strlen</code>'s private copy of the pointer. That means that calls like<br />
</p>
<div class="org-src-container">
<pre class="src src-C">strlen(<span style="color: #ffa07a;">"hello, world"</span>);         <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">string constant </span><span style="color: #cd853f;">*/</span>
<span style="color: #00ff7f;">strlen</span>(array);                  <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">char array[100]; </span><span style="color: #cd853f;">*/</span>
<span style="color: #00ff7f;">strlen</span>(ptr);                    <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">char *ptr; </span><span style="color: #cd853f;">*/</span>
</pre>
</div>
<p>
all work.<br />
</p>



<p>
As formal parameters in a function definition,<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">char</span> <span style="color: #9acd32;">s</span>[];
</pre>
</div>
<p>
and<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">char</span> *<span style="color: #9acd32;">s</span>;
</pre>
</div>
<p>
are equivalent; we prefer the latter because it says more explicitly that the variable is a pointer.<br />
</p>


<p>
It is possible to pass part of an array to a function, by passing a pointer to the beginning of the subarray. For example, if <code>a</code> is an array,<br />
</p>
<div class="org-src-container">
<pre class="src src-C">f(&amp;a[2])
</pre>
</div>
<p>
and<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00ff7f;">f</span>(a+2)
</pre>
</div>
<p>
both pass to the function <code>f</code> the address of the subarray that starts at <code>a[2]</code>.<br />
</p>
</div>
</div>



<div id="outline-container-org9c2ed23" class="outline-3">
<h3 id="org9c2ed23"><span class="section-number-3">5.4</span> Address Arithmetic</h3>
<div class="outline-text-3" id="text-5-4">
<p>
If <code>p</code> is a pointer to some element of an array, then <code>p++</code> increments <code>p</code> to point to the next element, and <code>p+=i</code> increments it to point <code>i</code> elements beyond where it currently does. These and similar constructions are the simples forms of pointer or address arithmetic.<br />
</p>


<p>
C is consistent and regular in its approach to address arithmetic: its integration of pointers, arrays, and address arithmetic is one of the strengths of the language.<br />
</p>


<hr />

<p>
<a href="code/chapter5/allocator.c">allocator.c</a><br />
</p>

<p>
C guarantees that zero is never a valid address for data. Pointers and integers are not interchangeable. Zero is the sole exception: the constant zero may be assigned to a pointer, and a pointer may be compared with the constant zero. The symbolic constant <code>NULL</code> is often used in place of zero, as a mnemonic to indicate more clearly that this is a special value for a pointer. <code>NULL</code> is defined in <code>&lt;stdio.h&gt;</code>.<br />
</p>




<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">if</span> (allocbuf + ALLOCSIZE - allocp &gt;= n) { <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">it fits </span><span style="color: #cd853f;">*/</span>
</pre>
</div>
<p>
and<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">if</span> (p &gt;= allocbuf &amp;&amp; p &lt; allocbuf + ALLOCSIZE)
</pre>
</div>
<p>
show serveral important facets of pointer arithmetic.<br />
</p>

<p>
First, pointer may be compared under certain circumstances. If <code>p</code> and <code>q</code> point to members of the same array, then relations like \(==, !=, <, >=\), etc., work properly. For example,<br />
</p>
<div class="org-src-container">
<pre class="src src-C">p &lt; q
</pre>
</div>
<p>
is true if <code>p</code> points to an earlier element of the array than <code>q</code> does. Any pointer can be meaningfully compared for equality or inequality with zero. But the behavior is undefined for arithmetic or comparisons with pointers that do not point to members of the same array. (There is one exception: the address of the first element past the end of an array can be used in pointer arithmetic.)<br />
</p>

<p>
Second, a pointer and an integer may be added or subtracted. The construction<br />
</p>
<div class="org-src-container">
<pre class="src src-C">p + n
</pre>
</div>
<p>
means the address of the n-th object beyond the one <code>p</code> currently points to.<br />
</p>


<p>
Pointer arithmetic is consistent. (scales according to the size of the object that the pointer points to)<br />
</p>


<p>
The valid pointer operations are:<br />
</p>
<ul class="org-ul">
<li>assignment of pointers of the same type<br /></li>
<li>adding or substrcting a pointer and an integer<br /></li>
<li>subtracting or comparing tow pointers to members of the same array<br /></li>
<li>assigning or comparing to zero<br /></li>
</ul>

<p>
All other pointer arithmetic is illegal.<br />
</p>
</div>
</div>



<div id="outline-container-orga51c1c7" class="outline-3">
<h3 id="orga51c1c7"><span class="section-number-3">5.5</span> Character Pointers and Functions</h3>
<div class="outline-text-3" id="text-5-5">
<p>
A <b>string constant</b>, written as<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffa07a;">"I am a string"</span>
</pre>
</div>
<p>
is an array of characters. In the internal representation, the array is terminated with the null character '\0' so that programs can find the end. The length in storage is thus one more than the number of characters between the double quotes.<br />
</p>


<div class="org-src-container">
<pre class="src src-C">printf(<span style="color: #ffa07a;">"hello, world\n"</span>);
</pre>
</div>
<p>
When a character string like this appears in a program, access to it is through a character pointer; <code>printf</code> receives a pointer to the beginning of the character array. That is, a string constant is accessed by a pointer to its first element.<br />
</p>


<p>
If <code>pmessage</code> is declared as<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">char</span> *<span style="color: #9acd32;">pmessage</span>;
</pre>
</div>
<p>
Then the statement<br />
</p>
<div class="org-src-container">
<pre class="src src-C">pmessage = <span style="color: #ffa07a;">"now is the time"</span>;
</pre>
</div>
<p>
assigns to <code>pmessage</code> a pointer to the character array. This is <b>not</b> a string copy; only pointers are involved. C does not provide any operators for processing an entire string of characters as a unit.<br />
</p>


<p>
There is an important difference between these definitions:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">char</span> <span style="color: #9acd32;">amessage</span>[] = <span style="color: #ffa07a;">"now is the time"</span>; <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">an array </span><span style="color: #cd853f;">*/</span> 
<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">pmessage</span> = <span style="color: #ffa07a;">"now is the time"</span>; <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">a pointer </span><span style="color: #cd853f;">*/</span>
</pre>
</div>
<p>
<code>amessage</code> is an array, just big enough to hold the sequence of characters and '\0' that initializes it. Individual characters within the array may be changed bug <code>amessage</code> will always refer to the same storage. On the other hand, <code>pmessage</code> is a pointer, initialized to point to a string constant; the pointer may subsequently be modified elsewhere, but the result is undefined if you try to modify the string contents.<br />
</p>


<div class="figure">
<p><img src="pics/pointer-and-array.png" alt="pointer-and-array.png" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org0dbed1a" class="outline-3">
<h3 id="org0dbed1a"><span class="section-number-3">5.6</span> Pointer Arrays: Pointers to Pointers</h3>
<div class="outline-text-3" id="text-5-6">
<p>
Since pointers are <b>variables</b> themselves, they can be stored in arrays just as other variables can.<br />
</p>
</div>
</div>







<div id="outline-container-org9321559" class="outline-3">
<h3 id="org9321559"><span class="section-number-3">5.7</span> Multi-dimentional Arrays</h3>
<div class="outline-text-3" id="text-5-7">
<p>
C provides rectangular multi-dimensional arrays, although in practice they are much less used than arrays of pointers.<br />
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">static</span> <span style="color: #9370db;">char</span> <span style="color: #9acd32;">daytab</span>[2][13] =
  {
   {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
   {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
  };

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">day_of_year set day of year from month and day </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">day_of_year</span>(<span style="color: #9370db;">int</span> <span style="color: #9acd32;">year</span>, <span style="color: #9370db;">int</span> <span style="color: #9acd32;">month</span>, <span style="color: #9370db;">int</span> <span style="color: #9acd32;">day</span>)
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">i</span>, <span style="color: #9acd32;">leap</span>;
  leap = year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0;
  <span style="color: #20b2aa; font-weight: bold;">for</span> (i = 1; i &lt; month; i++)
    day += daytab[leap][i];
  <span style="color: #20b2aa; font-weight: bold;">return</span> day;
}

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">month_day: set month, day from day of year </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">void</span> <span style="color: #00ff7f;">month_day</span>(<span style="color: #9370db;">int</span> <span style="color: #9acd32;">year</span>, <span style="color: #9370db;">int</span> <span style="color: #9acd32;">yearday</span>, <span style="color: #9370db;">int</span> *<span style="color: #9acd32;">pmonth</span>, <span style="color: #9370db;">int</span> *<span style="color: #9acd32;">pday</span>)
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">i</span>, <span style="color: #9acd32;">leap</span>;
  leap = year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0;
  <span style="color: #20b2aa; font-weight: bold;">for</span> (i = 1; yearday &gt; daytab[leap][i]; i++)
    yearday -= daytab[leap][i];
  *pmonth = i;
  *pday = yearday;
}
</pre>
</div>

<p>
An array is initialized by a list of initializers in braces; each row of a two-dimensional array is initialized by a corresponding sub-list.<br />
</p>

<p>
If a two-dimensional array is to be passed to a function, the parameter declaration in the function must include the number of columns; the number of rows is irrelevant, since what is passed is a pointer to an array of rows, where each row is an array of 13 ints. In this particular case, it is a pointer to objects that are arrays of 13 ints. More generally, only the first dimension (subscript) of an array is free; all the others have to be specified.<br />
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #00ff7f;">f</span>(<span style="color: #9370db;">int</span> <span style="color: #9acd32;">daytab</span>[2][13]) {...}
<span style="color: #00ff7f;">f</span>(<span style="color: #9370db;">int</span> <span style="color: #9acd32;">daytab</span>[][13]) {...}
<span style="color: #00ff7f;">f</span>(<span style="color: #9370db;">int</span> (*<span style="color: #9acd32;">daytab</span>)[13]) {...}
</pre>
</div>
</div>
</div>


<div id="outline-container-org41c9c17" class="outline-3">
<h3 id="org41c9c17"><span class="section-number-3">5.8</span> Initialization of Pointer Arrays</h3>
<div class="outline-text-3" id="text-5-8">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #cd853f;">/* </span><span style="color: #cd853f;">month_name: return name of n-th month </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">char</span> *<span style="color: #00ff7f;">month_name</span>(<span style="color: #9370db;">int</span> <span style="color: #9acd32;">n</span>)
{
  <span style="color: #20b2aa; font-weight: bold;">static</span> <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">name</span>[] =
    {
     <span style="color: #ffa07a;">"Illegal month"</span>,
     <span style="color: #ffa07a;">"January"</span>,
     <span style="color: #ffa07a;">"February"</span>,
     <span style="color: #ffa07a;">"March"</span>,
     <span style="color: #ffa07a;">"April"</span>,
     <span style="color: #ffa07a;">"May"</span>,
     <span style="color: #ffa07a;">"June"</span>,
     <span style="color: #ffa07a;">"July"</span>,
     <span style="color: #ffa07a;">"August"</span>,
     <span style="color: #ffa07a;">"September"</span>,
     <span style="color: #ffa07a;">"October"</span>,
     <span style="color: #ffa07a;">"November"</span>,
     <span style="color: #ffa07a;">"December"</span>
    };

  <span style="color: #20b2aa; font-weight: bold;">return</span> (n &lt; 1 || n &gt; 12) ? name[0] : name[n];
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org7abd336" class="outline-3">
<h3 id="org7abd336"><span class="section-number-3">5.9</span> Pointers vs. Multi-dimensional Arrays</h3>
<div class="outline-text-3" id="text-5-9">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #9acd32;">a</span>[10][20];
<span style="color: #9370db;">int</span> *<span style="color: #9acd32;">b</span>[10];
</pre>
</div>

<p>
<code>a[3][4]</code> and <code>b[3][4]</code> are both syntactically legal references to a single <code>int</code>. But <code>a</code> is a true two-dimensional array: 200 int-sized locations have been set aside, and the conventional rectangular subscript calculation \(20 \times rwo + col\) is used to find the element <code>a[row,col]</code>. For <code>b</code>, however, the definition only allocates 10 pointers and does not initialize them; initialization must be done explicitly, either statically or with code. Assuming that each element of b does point to a twenty-element array, then there will be 200 ints set aside, plus ten cells for the pointers. The important advantage of the pointer array is that the rows of the array may be of different lengths.<br />
</p>



<div class="figure">
<p><img src="pics/pointer-array.png" alt="pointer-array.png" /><br />
</p>
</div>


<div class="figure">
<p><img src="pics/multi-array.png" alt="multi-array.png" /><br />
</p>
</div>
</div>
</div>



<div id="outline-container-org49d1792" class="outline-3">
<h3 id="org49d1792"><span class="section-number-3">5.10</span> Command-line Arguments</h3>
<div class="outline-text-3" id="text-5-10">
<p>
When <code>main</code> is called, it is called with two arguments. The first (conventionally called <code>argc</code>, for argument count) is the number of command-line arguments the program was invoked with; the second (<code>argv</code>, for argument vector) is a pointer to an array of character strings that contain the arguments, one per string.<br />
</p>


<p>
By convention, <code>argv[0]</code> is the name by which the program was invoked, so <code>argc</code> is at least 1.<br />
</p>

<hr />
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #76ee00;">echo</span> hello, world
</pre>
</div>

<p>
<code>argc</code> is 3, and <code>argv[0], argv[1],</code> and <code>argv[2]</code> are "echo", "hello,", and "world" respectively. The standard requires that <code>argv[argc]</code> be a null pointer.<br />
</p>
</div>
</div>

<div id="outline-container-org223e951" class="outline-3">
<h3 id="org223e951"><span class="section-number-3">5.11</span> Pointers to Functions</h3>
<div class="outline-text-3" id="text-5-11">
<p>
In C, a function itself is not a variable, but it is possible to define pointers to functions, which can be assigned, placed in arrays, passed to functions, returned by functions, and so on.<br />
</p>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>

<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">MAXLINES</span> 5000           <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">max #lines to be sorted </span><span style="color: #cd853f;">*/</span>

<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">lineptr</span>[MAXLINES];        <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">pointers to text lines </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">readlines</span>(<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">lineptr</span>[], <span style="color: #9370db;">int</span> <span style="color: #9acd32;">nlines</span>);
<span style="color: #9370db;">void</span> <span style="color: #00ff7f;">writelines</span>(<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">lineptr</span>[], <span style="color: #9370db;">int</span> <span style="color: #9acd32;">nlines</span>);
<span style="color: #9370db;">void</span> <span style="color: #00ff7f;">qsort</span>(<span style="color: #9370db;">void</span> *<span style="color: #9acd32;">lineptr</span>[], <span style="color: #9370db;">int</span> <span style="color: #9acd32;">left</span>, <span style="color: #9370db;">int</span> <span style="color: #9acd32;">right</span>, <span style="color: #9370db;">int</span> (*<span style="color: #00ff7f;">comp</span>)(<span style="color: #9370db;">void</span> *, <span style="color: #9370db;">void</span> *));
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">numcmp</span> (<span style="color: #9370db;">char</span> *, <span style="color: #9370db;">char</span> *);

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">sort input lines </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">main</span>(<span style="color: #9370db;">int</span> <span style="color: #9acd32;">argc</span>, <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">argv</span>[])
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">nlines</span>;                   <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">number of input lines read </span><span style="color: #cd853f;">*/</span>
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">numberic</span> = 0;             <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">1 if number sort </span><span style="color: #cd853f;">*/</span>

  <span style="color: #20b2aa; font-weight: bold;">if</span> (argc &gt; 1 &amp;&amp; strcmp(argv[1], <span style="color: #ffa07a;">"-n"</span>) == 0)
    numeric = 1;

  <span style="color: #20b2aa; font-weight: bold;">if</span> ((nlines = readlines(lineptr, MAXLINES)) &gt;= 0) {
    qsort((<span style="color: #9370db;">void</span>**) lineptr, 0, nlines-1, (<span style="color: #9370db;">int</span> (*) (<span style="color: #9370db;">void</span>*, <span style="color: #9370db;">void</span>*)) (numberic ? numcmp : strcmp));
    writelines(lineptr, nlines);
    <span style="color: #20b2aa; font-weight: bold;">return</span> 0;
  } <span style="color: #20b2aa; font-weight: bold;">else</span> {
    printf(<span style="color: #ffa07a;">"input too big to sort\n"</span>);
    <span style="color: #20b2aa; font-weight: bold;">return</span> 1;
  }
}
</pre>
</div>

<p>
In the call to <code>qsort</code>, <code>strcmp</code> and <code>numcmp</code> are address of functions. Since they are known to be functions, the <code>&amp;</code> is not necessary, in the same way that it it not needed before any array name.<br />
</p>

<p>
The generic pointer type <code>void *</code> is used for the pointer arguments. Any pointer can be cast to <code>void *</code> and back again without loss of information, so we can call <code>qsort</code> by casting arguments to <code>void *</code>.<br />
</p>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #cd853f;">/* </span><span style="color: #cd853f;">qsort: sort v[left]...v[right] into increasing order </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">void</span> <span style="color: #00ff7f;">qsort</span>(<span style="color: #9370db;">void</span> *<span style="color: #9acd32;">v</span>[], <span style="color: #9370db;">int</span> <span style="color: #9acd32;">left</span>, <span style="color: #9370db;">int</span> <span style="color: #9acd32;">right</span>, <span style="color: #9370db;">int</span> (*<span style="color: #00ff7f;">comp</span>)(<span style="color: #9370db;">void</span> *, <span style="color: #9370db;">void</span> *))
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">i</span>, <span style="color: #9acd32;">mid</span>;

  <span style="color: #9370db;">void</span> <span style="color: #00ff7f;">swap</span>(<span style="color: #9370db;">void</span> *<span style="color: #9acd32;">v</span>[], <span style="color: #9370db;">int</span>, <span style="color: #9370db;">int</span>);

  <span style="color: #20b2aa; font-weight: bold;">if</span> (left &gt;= right)
    <span style="color: #20b2aa; font-weight: bold;">return</span>;

  swap(v, left, (left + right)/2);
  mid = left;

  <span style="color: #20b2aa; font-weight: bold;">for</span> (i = left+1; i &lt;= right; i++)
    <span style="color: #20b2aa; font-weight: bold;">if</span> ((*comp)(v[i], v[left]) &lt; 0)
      swap(v, ++mid, i);
  swap(v, left, mid);
  qsort(v, left, mid-1, comp);
  qsort(v, mid+1, right, comp);
}
</pre>
</div>

<p>
<code>*comp</code> is the function, and<br />
</p>
<div class="org-src-container">
<pre class="src src-C">(*comp)(v[i], v[left])
</pre>
</div>
<p>
is the call to it. The parentheses are needed so the components are correctly associated; without them,<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> *<span style="color: #00ff7f;">comp</span>(<span style="color: #9370db;">void</span> *, <span style="color: #9370db;">void</span> *) <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">WRONG </span><span style="color: #cd853f;">*/</span>
</pre>
</div>
<p>
says the <code>comp</code> is a function returning a pointer to an <code>int</code>, which is very different.<br />
</p>
</div>
</div>


<div id="outline-container-orgb2f2e96" class="outline-3">
<h3 id="orgb2f2e96"><span class="section-number-3">5.12</span> Complicated Declarations</h3>
<div class="outline-text-3" id="text-5-12">
<p>
<code>dcl</code> is the more complex. It converts a C declaration into a word description.<br />
</p>

<pre class="example">
dcl:        optional *'s direct-dcl
direct-dcl name
                (dcl)
		direct-dcl()
		direct-dcl[optional size]
</pre>
<p>
In words, a dcl is a direct-dcl, perhaps preceded by *'s. A direct-dcl is a name, or a parenthesized dcl, or a direct-dcl followed by parentheses, or a direct-dcl followed by brackets with an optional size.<br />
</p>


<div class="figure">
<p><img src="pics/dcl.png" alt="dcl.png" /><br />
</p>
</div>

<p>
The heart of the <code>dcl</code> program is a pair of functions, <code>dcl</code> and <code>dirdcl</code>, that parse a declaration according to this grammar. Because the grammar is recursively defined, the functions call each other recursively as they recognize pieces of a declaration; the program is called a recursive-descent parser.<br />
</p>
</div>
</div>
</div>


<div id="outline-container-org7340642" class="outline-2">
<h2 id="org7340642"><span class="section-number-2">6</span> Structures</h2>
<div class="outline-text-2" id="text-6">
<p>
A structure is a collection of one or more variables, possibly of different types, grouped together under a single name for convenient handling. Structures help to organize complicated data, particularly in large programs, because they permit a group of related variables to be treated as a unit instead of as separate entities.<br />
</p>
</div>

<div id="outline-container-orgc587f35" class="outline-3">
<h3 id="orgc587f35"><span class="section-number-3">6.1</span> Basics of Structures</h3>
<div class="outline-text-3" id="text-6-1">

<div class="figure">
<p><img src="pics/point.png" alt="point.png" /><br />
</p>
</div>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">point</span> {
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">x</span>;
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">y</span>;
}
</pre>
</div>

<p>
The keyword <code>struct</code> introduces a structure declaration, which is a list of declarations enclosed in braces. An optional name called a <b>structure tag</b> may follow the word <code>struct</code> (as with <code>point</code> here). The tag names this kind of structure, and can be used subsequently as a shorthand for the part of the declaration in braces.<br />
</p>

<p>
The variables named in a structure are called <code>members</code>. A structure member or tag and an ordinary (i.e., non-member) variable can have the same name without conflict, since they can always be distinguished by context.<br />
</p>

<p>
A <code>struct</code> declaration defines a type. The right brace that terminates the list of members may be followed by a list of variables, just as for any basic type. That is,<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">struct</span> { ... } <span style="color: #9acd32;">x</span>, <span style="color: #9acd32;">y</span>, <span style="color: #9acd32;">z</span>;
</pre>
</div>
<p>
is syntactically anologous to<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #9acd32;">x</span>, <span style="color: #9acd32;">y</span>, <span style="color: #9acd32;">z</span>;
</pre>
</div>

<p>
A structure declaration that is not followed by a list of variables reserves no storage; it merely describes a template or shape of a structure. If the declaration is tagged, however, the tag can be used later in definitions of instances of the structure.<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">point</span> <span style="color: #9acd32;">pt</span>;
</pre>
</div>
<p>
defines a variable <code>pt</code> which is a structure of type <code>struct point</code>.<br />
</p>


<p>
A structure can be initialized by following its definition with a list of initializers, each a constant expression, for the members:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">maxpt</span> = { 320, 200 };
</pre>
</div>
<p>
An automatic structure may also be initialized by assignment or by calling a function that returns a structure of the right type.<br />
</p>



<p>
A member of a particular structure is referred to in an expression by a construction of the form<br />
</p>
<pre class="example">
structure-name.member
</pre>
<div class="org-src-container">
<pre class="src src-C">printf(<span style="color: #ffa07a;">"%d,%d"</span>, pt.x, pt.y);
</pre>
</div>

<p>
Structures can be nested.<br />
</p>


<div class="figure">
<p><img src="pics/rect.png" alt="rect.png" /><br />
</p>
</div>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">rect</span> {
    <span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">point</span> <span style="color: #9acd32;">pt1</span>;
    <span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">point</span> <span style="color: #9acd32;">pt2</span>;
};

<span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">rect</span> <span style="color: #9acd32;">screen</span>;

printf(<span style="color: #ffa07a;">"%d"</span>, screen.pt1.x);
</pre>
</div>
</div>
</div>


<div id="outline-container-org94b653e" class="outline-3">
<h3 id="org94b653e"><span class="section-number-3">6.2</span> Structures and Functions</h3>
<div class="outline-text-3" id="text-6-2">
<p>
The only legal operations on a structure are copying it or assigning to it as a unit, taking its address with &amp;, and accessing its members. Copy and assignment include passing arguments to functions and returning values from functions as well. Structures may not be compared. A structure may be initialized by a list of constant member values; an automatic structure may also be initialized by an assignment.<br />
</p>


<p>
If a large structure is to be passed to a function, it is generally more efficient to pass a pointer than to copy the whole structure. Structure pointers are just like pointers to ordinary variables. The declaration<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">point</span> *<span style="color: #9acd32;">pp</span>;
</pre>
</div>
<p>
says that <code>pp</code> is a pointer to a structure of type <code>struct point</code>.<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">point</span> <span style="color: #9acd32;">origin</span>, *<span style="color: #9acd32;">pp</span>;
pp = &amp;origin;
printf(<span style="color: #ffa07a;">"origin is (%d,%d)\n"</span>, (*pp).x, (*pp).y);
</pre>
</div>
<p>
The parentheses are necessary in <code>(*pp).x</code> because the precedence of the structure member operator <code>.</code> is higher then <code>*</code>.<br />
</p>


<p>
Pointers to structures are so frequently used that an alternative notation is provided as a shorthand. If <code>p</code> is a pointer to a structure, then<br />
</p>
<pre class="example">
p-&gt;mumber-of-structure
</pre>
<p>
refers to the particular member.<br />
</p>
<div class="org-src-container">
<pre class="src src-C">printf(<span style="color: #ffa07a;">"origin is (%d,%d)\n"</span>, pp-&gt;x, pp-&gt;y);
</pre>
</div>


<p>
Both <code>.</code> and <code>-&gt;</code> associate from left to right, so if we have<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">rect</span> <span style="color: #9acd32;">r</span>, *<span style="color: #9acd32;">rp</span> = &amp;r;
</pre>
</div>
<p>
then these four expressions are equivalent:<br />
</p>
<div class="org-src-container">
<pre class="src src-C">r.pt1.x 
rp-&gt;pt1.x 
(r.pt1).x 
(rp-&gt;pt1).x
</pre>
</div>

<hr />
<pre class="example">
The structure operators . and -&gt;, together with () for function calls and [] for subscripts, 
are at the top of the precedence hierarchy and thus bind very tightly. 
</pre>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">struct</span> {
    <span style="color: #9370db;">int</span> <span style="color: #9acd32;">len</span>;
    <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">str</span>;
} *<span style="color: #9acd32;">p</span>;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C">++p-&gt;len
</pre>
</div>
<p>
increments <code>len</code>, not <code>p</code>.<br />
</p>
<div class="org-src-container">
<pre class="src src-C">*p-&gt;str
</pre>
</div>
<p>
fetches whatever <code>str</code> points to;<br />
</p>
<div class="org-src-container">
<pre class="src src-C">*p-&gt;str++
</pre>
</div>
<p>
increments <code>str</code> after accessing whatever it points to.<br />
</p>
<div class="org-src-container">
<pre class="src src-C">*p++-&gt;str
</pre>
</div>
<p>
increments <code>p</code> after accessing whatever <code>str</code> points to.<br />
</p>
<hr />
</div>
</div>

<div id="outline-container-org263f715" class="outline-3">
<h3 id="org263f715"><span class="section-number-3">6.3</span> Arrays of Structures</h3>
<div class="outline-text-3" id="text-6-3">
<p>
Consider writing a program to count the occurrences of each C keyword. We need an array of character strings to hold the names, and an array of integers for the counts. One possibility is to use two parallel arrays, <code>keyword</code> and <code>keycount</code>, as in<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">char</span> *<span style="color: #9acd32;">keyword</span>[NKEYS]; 
<span style="color: #9370db;">int</span> <span style="color: #9acd32;">keycount</span>[NKEYS];
</pre>
</div>

<p>
But the very fact that <b>the arrays are parallel suggests a different organization, an array of structures</b>. Each keyword is a pair:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">char</span> *<span style="color: #9acd32;">word</span>;
<span style="color: #9370db;">int</span> <span style="color: #9acd32;">count</span>;
</pre>
</div>
<p>
and there is an array of pairs.<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">key</span> {
    <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">word</span>;
    <span style="color: #9370db;">int</span> <span style="color: #9acd32;">count</span>;
} <span style="color: #9acd32;">keytab</span>[NKEYS];
</pre>
</div>
<p>
declares a structure type <code>key</code>, defines an array <code>keytab</code> of structures of this type, and sets aside storage for them.<br />
</p>

<p>
Since the structure <code>keytab</code> contains a constant set of names, it is easiest to make it an external variable and initialize it once and for all when it is defined.<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">key</span> {
    <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">word</span>;
    <span style="color: #9370db;">int</span> <span style="color: #9acd32;">count</span>; 
} <span style="color: #9acd32;">keytab</span>[] = { 
    <span style="color: #ffa07a;">"auto"</span>, 0,
    <span style="color: #ffa07a;">"break"</span>, 0,
    <span style="color: #ffa07a;">"case"</span>, 0,
    <span style="color: #ffa07a;">"char"</span>, 0,
    <span style="color: #ffa07a;">"const"</span>, 0,
    <span style="color: #ffa07a;">"continue"</span>, 0,
    <span style="color: #ffa07a;">"default"</span>, 0,
    <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">... </span><span style="color: #cd853f;">*/</span>
    <span style="color: #ffa07a;">"unsigned"</span>, 0,
    <span style="color: #ffa07a;">"void"</span>, 0,
    <span style="color: #ffa07a;">"volatile"</span>, 0,
    <span style="color: #ffa07a;">"while"</span>, 0
};
</pre>
</div>

<p>
The initializers are listed in pairs corresponding to the structure members. It would be more precise to enclose the initializers for each "row" or structure in braces, as in<br />
</p>
<div class="org-src-container">
<pre class="src src-C">{ <span style="color: #ffa07a;">"auto"</span>, 0 },
{ <span style="color: #ffa07a;">"break"</span>, 0 },
...
</pre>
</div>
<p>
but inner braces are not necessary when the initializers are simple variables or character strings, and when all are present.<br />
</p>

<p>
(for <code>NKEYS</code>)<br />
The size of the array is completely determined at compile time. The size of the array is the size of one entry times the number of entries, so the number of entries is just<br />
</p>
\begin{equation}
number\ of\ entries = \frac{size\ of\ array}{size\ of\ entry}
\end{equation}

<p>
C provides a compile-time unary operator called <code>sizeof</code> that can be used to compute the size of any object. The expressions<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">sizeof</span> object
<span style="color: #cd853f;">// </span><span style="color: #cd853f;">and</span>
<span style="color: #20b2aa; font-weight: bold;">sizeof</span> (typename)
</pre>
</div>
<p>
yield an integer equal to the size of the specified object or type in bytes. (Strictly, <code>sizeof</code> produces an unsigned integer value whose type, <code>size_t</code>, is defined in the header &lt;stddef.h&gt;.)<br />
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">NKEYS</span> (<span style="color: #20b2aa; font-weight: bold;">sizeof</span> keytab / <span style="color: #20b2aa; font-weight: bold;">sizeof</span>(<span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">key</span>))
</pre>
</div>
<p>
A <code>sizeof</code> can not be used in a <code>#if</code> line, because the preprocessor does not parse type names. But the expression in the <code>#define</code> is not evaluated by the preprocessor, so the code here is legal.<br />
</p>

<hr />
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;ctype.h&gt;</span>
<span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>

<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">MAXWORD</span> 100


<span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">key</span> {
    <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">word</span>;
    <span style="color: #9370db;">int</span> <span style="color: #9acd32;">count</span>; 
} <span style="color: #9acd32;">keytab</span>[] = {
    <span style="color: #ffa07a;">"auto"</span>, 0,
    <span style="color: #ffa07a;">"break"</span>, 0,
    <span style="color: #ffa07a;">"case"</span>, 0,
    <span style="color: #ffa07a;">"char"</span>, 0,
    <span style="color: #ffa07a;">"const"</span>, 0,
    <span style="color: #ffa07a;">"continue"</span>, 0,
    <span style="color: #ffa07a;">"default"</span>, 0,
    <span style="color: #ffa07a;">"do"</span>, 0,
    <span style="color: #ffa07a;">"double"</span>, 0,
    <span style="color: #ffa07a;">"else"</span>, 0,
    <span style="color: #ffa07a;">"enum"</span>, 0,
    <span style="color: #ffa07a;">"extern"</span>, 0,
    <span style="color: #ffa07a;">"float"</span>, 0,
    <span style="color: #ffa07a;">"for"</span>, 0,
    <span style="color: #ffa07a;">"goto"</span>, 0,
    <span style="color: #ffa07a;">"if"</span>, 0,
    <span style="color: #ffa07a;">"inline"</span>, 0,
    <span style="color: #ffa07a;">"int"</span>, 0,
    <span style="color: #ffa07a;">"long"</span>, 0,
    <span style="color: #ffa07a;">"register"</span>, 0,
    <span style="color: #ffa07a;">"restrict "</span>, 0,
    <span style="color: #ffa07a;">"return"</span>, 0,
    <span style="color: #ffa07a;">"short"</span>, 0,
    <span style="color: #ffa07a;">"signed"</span>, 0,
    <span style="color: #ffa07a;">"sizeof"</span>, 0,
    <span style="color: #ffa07a;">"static"</span>, 0,
    <span style="color: #ffa07a;">"struct"</span>, 0,
    <span style="color: #ffa07a;">"switch"</span>, 0,
    <span style="color: #ffa07a;">"typedef"</span>, 0,
    <span style="color: #ffa07a;">"union"</span>, 0,
    <span style="color: #ffa07a;">"unsigned"</span>, 0,
    <span style="color: #ffa07a;">"void"</span>, 0,
    <span style="color: #ffa07a;">"volatile"</span>, 0,
    <span style="color: #ffa07a;">"while"</span>, 0

};

<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">NKEYS</span> (<span style="color: #20b2aa; font-weight: bold;">sizeof</span> keytab / <span style="color: #20b2aa; font-weight: bold;">sizeof</span>(<span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">key</span>))

<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">getword</span>(<span style="color: #9370db;">char</span> *, <span style="color: #9370db;">int</span>);
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">binsearch</span>(<span style="color: #9370db;">char</span> *, <span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">key</span> *, <span style="color: #9370db;">int</span>);

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">count C keywords </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">main</span>(<span style="color: #9370db;">void</span>)
{
    <span style="color: #9370db;">int</span> <span style="color: #9acd32;">n</span>;
    <span style="color: #9370db;">char</span> <span style="color: #9acd32;">word</span>[MAXWORD];

    <span style="color: #20b2aa; font-weight: bold;">while</span> (getword(word, MAXWORD) != EOF)
        <span style="color: #20b2aa; font-weight: bold;">if</span> (isalpha(word[0]))
            <span style="color: #20b2aa; font-weight: bold;">if</span> ((n = binsearch(word, keytab, NKEYS)) &gt;= 0)
                keytab[n].count++;

    <span style="color: #20b2aa; font-weight: bold;">for</span> (n = 0; n &lt; NKEYS; n++)
        <span style="color: #20b2aa; font-weight: bold;">if</span> (keytab[n].count &gt; 0) <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">only print keyword with count &gt; 0 </span><span style="color: #cd853f;">*/</span>
            printf(<span style="color: #ffa07a;">"%4d %s\n"</span>, keytab[n].count, keytab[n].word);

    <span style="color: #20b2aa; font-weight: bold;">return</span> 0;
}

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">binsearch: find word in tab[0]..tab[n-1] </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">binsearch</span>(<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">word</span>, <span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">key</span> <span style="color: #9acd32;">tab</span>[], <span style="color: #9370db;">int</span> <span style="color: #9acd32;">n</span>)
{
    <span style="color: #9370db;">int</span> <span style="color: #9acd32;">cond</span>;
    <span style="color: #9370db;">int</span> <span style="color: #9acd32;">low</span>, <span style="color: #9acd32;">high</span>, <span style="color: #9acd32;">mid</span>;

    low = 0;
    high = n - 1;
    <span style="color: #20b2aa; font-weight: bold;">while</span> (low &lt;= high) {
        mid = (low + high) / 2;
        <span style="color: #20b2aa; font-weight: bold;">if</span> ((cond = strcmp(word, tab[mid].word)) &lt; 0)
            high = mid -1;
        <span style="color: #20b2aa; font-weight: bold;">else</span> <span style="color: #20b2aa; font-weight: bold;">if</span> (cond &gt; 0)
            low = mid + 1;
        <span style="color: #20b2aa; font-weight: bold;">else</span>
            <span style="color: #20b2aa; font-weight: bold;">return</span> mid;
    }
    <span style="color: #20b2aa; font-weight: bold;">return</span> -1;
}


<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">getword: get next word or character from input </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">getword</span>(<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">word</span>, <span style="color: #9370db;">int</span> <span style="color: #9acd32;">lim</span>)
{
    <span style="color: #9370db;">int</span> <span style="color: #9acd32;">c</span>, <span style="color: #00ff7f;">getch</span>(<span style="color: #9370db;">void</span>);
    <span style="color: #9370db;">void</span> <span style="color: #00ff7f;">ungetch</span>(<span style="color: #9370db;">int</span>);
    <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">w</span> = word;

    <span style="color: #20b2aa; font-weight: bold;">while</span> (isspace(c =getch()))
        ;

    <span style="color: #20b2aa; font-weight: bold;">if</span> (c != EOF)
        *w++ = c;
    <span style="color: #20b2aa; font-weight: bold;">if</span> (!isalpha(c)) {
        *w = <span style="color: #ffa07a;">'\0'</span>;
        <span style="color: #20b2aa; font-weight: bold;">return</span> c;
    }

    <span style="color: #20b2aa; font-weight: bold;">for</span> ( ; --lim &gt; 0; w++)
        <span style="color: #20b2aa; font-weight: bold;">if</span> (!isalnum(*w = getch())) {
            ungetch(*w);
            <span style="color: #20b2aa; font-weight: bold;">break</span>;
        }
    *w = <span style="color: #ffa07a;">'\0'</span>;
    <span style="color: #20b2aa; font-weight: bold;">return</span> word[0];

}

</pre>
</div>
</div>
</div>


<div id="outline-container-org13e87d6" class="outline-3">
<h3 id="org13e87d6"><span class="section-number-3">6.4</span> Pointers to Structures</h3>
<div class="outline-text-3" id="text-6-4">
<p>
<a href="code/chapter6/keyword-counting.c">keyword-counting.c</a><br />
</p>

<p>
Note:<br />
The addition of pointers is illeage.<br />
Subtraction is legal.<br />
</p>
</div>
</div>

<div id="outline-container-org962d990" class="outline-3">
<h3 id="org962d990"><span class="section-number-3">6.5</span> Self-referential Structure</h3>
<div class="outline-text-3" id="text-6-5">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">tnode</span> {                  <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">the tree node </span><span style="color: #cd853f;">*/</span>
  <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">word</span>;                   <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">points to the text </span><span style="color: #cd853f;">*/</span>
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">count</span>;                    <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">number of occurrences </span><span style="color: #cd853f;">*/</span>
  <span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">tnode</span> *<span style="color: #9acd32;">left</span>;           <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">left child </span><span style="color: #cd853f;">*/</span>
  <span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">tnode</span> *<span style="color: #9acd32;">lright</span>;         <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">right child </span><span style="color: #cd853f;">*/</span>
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">t</span> { 
    ...
    structs*p; <span style="color: #cd853f;">/*</span><span style="color: #cd853f;">ppointstoans</span><span style="color: #cd853f;">*/</span> 
};

<span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">s</span> { 
    ...
    structt*q; <span style="color: #cd853f;">/*</span><span style="color: #cd853f;">qpointstoat</span><span style="color: #cd853f;">*/</span> 
};
</pre>
</div>



<p>
Note:<br />
The <code>alloc</code> does not guarantee any particular alignment.<br />
The standard library function <code>malloc</code>, which does. &lt;stdli.h&gt;<br />
<code>malloc</code> returns a pointer to void, then explicitly coerce the pointer into the desired type with a cast.<br />
</p>


<p>
<a href="code/chapter6/word-counting.c">word-counting.c</a><br />
</p>
</div>
</div>


<div id="outline-container-org8d0d667" class="outline-3">
<h3 id="org8d0d667"><span class="section-number-3">6.6</span> Table Lookup</h3>
<div class="outline-text-3" id="text-6-6">
<p>
<a href="code/chapter6/lookup-table.c">lookup-table.c</a><br />
</p>
</div>
</div>

<div id="outline-container-org747bce6" class="outline-3">
<h3 id="org747bce6"><span class="section-number-3">6.7</span> Typedef</h3>
<div class="outline-text-3" id="text-6-7">
<p>
C provides a facility called typedef for creating new data type names.<br />
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">typedef</span> <span style="color: #9370db;">int</span> <span style="color: #9370db;">Length</span>;
</pre>
</div>
<p>
makes the name <code>Length</code> a synonym for <code>int</code>. The type <code>Length</code> can be used in declarations, casts, etc., in exactly the same ways that the <code>int</code> type can be:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">Length</span> <span style="color: #9acd32;">len</span>, <span style="color: #9acd32;">maxlen</span>;
<span style="color: #9370db;">Length</span> *<span style="color: #9acd32;">lengths</span>[];
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">typedef</span> <span style="color: #9370db;">char</span> *<span style="color: #9370db;">String</span>;

<span style="color: #9370db;">String</span> <span style="color: #9acd32;">p</span>, <span style="color: #9acd32;">lineptr</span>[MAXLINES], <span style="color: #00ff7f;">alloc</span>(<span style="color: #9370db;">int</span>);
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">strcmp</span>(<span style="color: #9370db;">String</span>,<span style="color: #9370db;">String</span>);
p = (<span style="color: #9370db;">String</span>) malloc(100);
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">typedef</span> <span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">tnode</span> *<span style="color: #9370db;">Treeptr</span>;

<span style="color: #20b2aa; font-weight: bold;">typedef</span> <span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">tnode</span> {
  <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">word</span>;
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">count</span>;
  <span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">tnode</span> *<span style="color: #9acd32;">left</span>;
  <span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">tnode</span> *<span style="color: #9acd32;">right</span>;
} <span style="color: #9370db;">Treenode</span>;

<span style="color: #9370db;">Treeptr</span> <span style="color: #00ff7f;">talloc</span>(<span style="color: #9370db;">void</span>)
{
  <span style="color: #20b2aa; font-weight: bold;">return</span> (<span style="color: #9370db;">Treeptr</span>) malloc(<span style="color: #20b2aa; font-weight: bold;">sizeof</span>(Treenode));
}
</pre>
</div>

<p>
A <code>typedef</code> declaration does not create a new type in any sense. It merely adds a new name for some existing type. Nore are there any new semantics.<br />
</p>

<p>
<code>typedef</code> can cope with textual substitutions:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">typedef</span> <span style="color: #9370db;">int</span> (*<span style="color: #9370db;">PFI</span>)(<span style="color: #9370db;">char</span> *, <span style="color: #9370db;">char</span> *);
</pre>
</div>
<p>
creates the type <code>PFI</code>, for "pointer to function (of two char * arguments) returning <code>int</code>"<br />
</p>




<p>
Besides purely aesthetic issues, there are two main reasons for using typedefs:<br />
</p>
<dl class="org-dl">
<dt>to parameterize a program against portability problems.</dt><dd>If typedefs are used for data types that may be machine-dependent, only the typedefs need change when the program is moved.<br /></dd>
<dt>to provide better documentation for a program.</dt><dd>a type called <code>Treeptr</code> may be easier to understand than one declared only as a pointer to a complicated structure.<br /></dd>
</dl>
</div>
</div>


<div id="outline-container-org4187f53" class="outline-3">
<h3 id="org4187f53"><span class="section-number-3">6.8</span> Unions</h3>
<div class="outline-text-3" id="text-6-8">
<p>
A <b>union</b> is a variable that may hold (at different times) objects of different types and sizes, with the compiler keeping track of size and alignment requirements. Unions provide a way to manipulate different kinds of data in a single area of storage, without embedding any machine-dependent information in the program.<br />
</p>

<hr />
<p>
As an example such as might be found in a compiler symbol table manager, suppose that a constant may be an <code>int</code>, a <code>float</code>, or a character pointer. The value of a particular constant must be stored in a variable of the proper type, yet it is most convenient for table management if the value occupies the same amount of storage and is stored in the same place regardless of its type. This is the purpose of a union - a single variable that can legitimately hold any of one of several types. The syntax is based on structures:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">union</span> <span style="color: #9370db;">u_tag</span> {
    <span style="color: #9370db;">int</span> <span style="color: #9acd32;">ival</span>;
    <span style="color: #9370db;">float</span> <span style="color: #9acd32;">fval</span>;
    <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">sval</span>;
} <span style="color: #9acd32;">u</span>;
</pre>
</div>
<p>
The variable <code>u</code> will be large enough to hold the largest of the three types; the specific size is implementation-dependent. Any of these types may be assigned to <code>u</code> and then used in expressions, so long as the usage is consistent: the type retrieved must be the type most recently stored. It is the programmer's responsibility to keep track of which type is currently stored in a union; the results are implementation-dependent if something is stored as one type and extracted as another.<br />
</p>
<hr />

<p>
Syntactically, members of a union are accessed as<br />
</p>
<pre class="example">
union-name.member
union-pointer-&gt;memeber
</pre>
<p>
just as for structures.<br />
</p>


<p>
A union may only be initialized with a value of the type of its first member<br />
</p>
</div>
</div>


<div id="outline-container-orgbbd3ebe" class="outline-3">
<h3 id="orgbbd3ebe"><span class="section-number-3">6.9</span> Bit-fields</h3>
<div class="outline-text-3" id="text-6-9">
<p>
When storage space is at a premium, it may be necessary to pack several objects into a single machine word; one common use is a set of single-bit flags in applications like compiler symbol tables.<br />
</p>


<p>
Imagine a fragment of a compiler that manipulates a symbol table. Each identifier in a program has certain information associated with it, for example, whether or not it is a keyword, whether or not it is external and/or static, and so on. The most compact way to encode such information is a set of one-bit flags in a single <code>char</code> or <code>int</code>.<br />
</p>

<p>
The usual way this is done is to define a set of ``masks'' corresponding to the relevant bit positions, as in<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">KEYWORD</span> 
<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">EXTRENAL</span> 
<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">STATIC</span>
</pre>
</div>
<p>
or<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">enum</span> { <span style="color: #9acd32;">KEYWORD</span> = 01, <span style="color: #9acd32;">EXTERNAL</span> = 02, <span style="color: #9acd32;">STATIC</span> = 04 };
</pre>
</div>
<p>
The numbers must be powers of two. Then accessing the bits becomes a matter of ``bit-fiddling'' with the shifting, masking, and complementing operators.<br />
</p>
<pre class="example">
flags |= EXTERNAL | STATIC
</pre>
<p>
turns on the <code>EXTERNAL</code> and <code>STATIC</code> bits in <code>flags</code>, while<br />
</p>
<div class="org-src-container">
<pre class="src src-C">flags &amp;= ~(EXTERNAL | STATIC);
</pre>
</div>
<p>
turns them off, and<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">if</span> ((flags &amp; (EXTERNAL | STATIC)) == 0)
</pre>
</div>
<p>
is true if both bits are off.<br />
</p>


<p>
As an alternative C offers the capability of defining and accessing fields within a word directly rather than by bitwise logical operators. A bit-field, or field for short, is a set of adjacent bits within a single implementation-defined storage unit that we will call a ``word.''<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">struct</span> {
    <span style="color: #9370db;">unsigned</span> <span style="color: #9370db;">int</span> <span style="color: #9acd32;">is_keyword</span> : 1;
    <span style="color: #9370db;">unsigned</span> <span style="color: #9370db;">int</span> <span style="color: #9acd32;">is_extern</span>  : 1;
    <span style="color: #9370db;">unsigned</span> <span style="color: #9370db;">int</span> <span style="color: #9acd32;">is_static</span>  : 1;
} <span style="color: #9acd32;">flags</span>;
</pre>
</div>
<p>
This defines a variable table called <code>flags</code> that contains three 1-bit fields. The number following the colon represents the field width in bits. The fields are declared <code>unsigned int</code> to ensure that they are unsigned quantities.<br />
</p>

<p>
Individual fields are referenced in the same way as other structure members: flags.is_keyword, flags.is_extern, etc. Fields behave like small integers, and may participate in arithmetic expressions just like other integers.<br />
</p>
<div class="org-src-container">
<pre class="src src-C">flags.is_extern = flags.is_static = 1;
</pre>
</div>
<p>
to turn the bits on;<br />
</p>
<div class="org-src-container">
<pre class="src src-C">flags.is_extern = flags.is_static = 0;
</pre>
</div>
<p>
to turn the bits off;<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">if</span> (flags.is_extern == 0 &amp;&amp; flags.is_static == 0)
</pre>
</div>
<p>
to test them.<br />
</p>

<p>
Almost everything about fields is implementation-dependent. Whether a field may overlap a word boundary is implementation-defined. Fields need not be names; unnamed fields (a colon and width only) are used for padding. The special width 0 may be used to force alignment at the next word boundary.<br />
</p>

<p>
Fields are assigned left to right on some machines and right to left on others. This means that although fields are useful for maintaining internally-defined data structures, the question of which end comes first has to be carefully considered when picking apart externally-defined data; programs that depend on such things are not portable. Fields may be declared only as ints; for portability, specify <code>signed</code> or <code>unsigned</code> explicitly. They are not arrays and they do not have addresses, so the &amp; operator cannot be applied on them.<br />
</p>
</div>
</div>
</div>





<div id="outline-container-org7eb19f7" class="outline-2">
<h2 id="org7eb19f7"><span class="section-number-2">7</span> Input and Output</h2>
<div class="outline-text-2" id="text-7">
<p>
Input and output are not part of the C language itself. The standard library is a set of functions that provide intput and output, string handling, storage management, mathematical routines, and a variety of other services for C programs. The ANSI standard defines these library functions precisely, so that they can exist in compatible form on any system where C exists.<br />
</p>

<p>
The properties of library functions are specified in more than a dozen of headers.<br />
</p>
</div>

<div id="outline-container-org35fd43d" class="outline-3">
<h3 id="org35fd43d"><span class="section-number-3">7.1</span> Standard Input and Output</h3>
<div class="outline-text-3" id="text-7-1">
<p>
The simplest input mechanism is to read one character at a time from the <b>standard input</b>, normally the keyword, with <code>getchar</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #00ff7f;">getchar</span>(<span style="color: #9370db;">void</span>)               
</pre>
</div>
<p>
returns the next input character each time it is called, or EOF when it encounters end of file.<br />
</p>


<p>
In many environments, a file may be substituted for the keyboard by using the &lt; convention for input <b>redirection</b>:<br />
if a program <code>prog</code> uses <code>getchar</code>, then the command line<br />
</p>
<div class="org-src-container">
<pre class="src src-sh">prog &lt; infile
</pre>
</div>
<p>
causes <code>prog</code> to read characters from infile instead. The switching of the input is done in such a way that <code>prog</code> itself is oblivious to the change; in particular, the string ``&lt; infile'' is not included in the command-line arguments in <code>argv</code>.<br />
</p>

<p>
Input switching is also invisible if the input comes from another program via a <b>pipe</b> mechanism:<br />
on some systems, the command line<br />
</p>
<div class="org-src-container">
<pre class="src src-sh">otherprog | prog
</pre>
</div>
<p>
runs the two programs <code>otherprog</code> and <code>prog</code>, and piples the standard output of <code>otherprog</code> into the standard input for <code>prog</code>.<br />
</p>


<p>
The function<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #00ff7f;">putchar</span>(<span style="color: #9370db;">int</span>)
</pre>
</div>
<p>
is used for output: <code>putchar(c)</code> puts the character <code>c</code> on the <code>standard output</code>, which is by default the screen. <code>putchar</code> returns the character written, or <code>EOF</code> in an error occurs.<br />
</p>

<p>
Again, output can usually be directed to a file with <b>redirection</b> and <b>pipeline</b>.<br />
</p>
<div class="org-src-container">
<pre class="src src-sh">prog &gt; outputfile
prog | anotherprog
</pre>
</div>


<p>
Output produced by <code>printf</code> also finds its way to the standard output.<br />
</p>



<p>
Each source file that refers to an input/output library function must contain the line<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
</pre>
</div>
<p>
before the first reference.<br />
</p>
</div>
</div>

<div id="outline-container-org900cf5b" class="outline-3">
<h3 id="org900cf5b"><span class="section-number-3">7.2</span> Formatted Output - printf</h3>
<div class="outline-text-3" id="text-7-2">
<p>
The output function <code>printf</code> translates internal values to characters.<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #00ff7f;">printf</span>(<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">format</span>, arg1, arg2, ...);
</pre>
</div>
<p>
<code>printf</code> converts, formats, and prints its arguments on the standard output under control of the <code>format</code>. It returns the number of characters printed.<br />
</p>

<p>
The format string contains two types of objects:<br />
</p>
<dl class="org-dl">
<dt>ordinary characters</dt><dd>which are copied to the output stream, and<br /></dd>
<dt>conversion specifications</dt><dd>each of which causes conversion and printing of the next successive argument to printf.<br /></dd>
</dl>
<p>
Each conversion specification begins with a % and ends with a conversion character. Between the % and the conversion character there may be, <b>in order</b>:<br />
</p>
<ul class="org-ul">
<li>A minus sign, which specifies left adjustment of the converted argument.<br /></li>
<li>A number that specifies the minimum field width.<br /></li>
<li>A period, which separates the field width from the precision.<br /></li>
<li>A number, the precision, that specifies the maximum number of characters to be printed from a string, or the number of digits after the decimal point of a floating-point value, or the minimum number of digits for an integer.<br /></li>
<li>An <code>h</code> if the integer is to be printed as a <code>short</code>, or <code>l</code> if as a <code>long</code>.<br /></li>
</ul>


<div class="figure">
<p><img src="pics/basic-printf-conversions.png" alt="basic-printf-conversions.png" /><br />
</p>
</div>

<p>
A width or precision may be specified as *, in which case the value is computed by converting the next argument (which must be an <code>int</code>).<br />
For example, to print at most <code>max</code> characters from a string <code>s</code>,<br />
</p>
<div class="org-src-container">
<pre class="src src-C">printf(<span style="color: #ffa07a;">"%.*s"</span>, max, s)
</pre>
</div>


<p>
The function <code>sprintf</code> does the same conversion as <code>printf</code> does, but stores the output in a string:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #00ff7f;">sprintf</span>(<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">string</span>, <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">format</span>, arg1, arg2, ...);
</pre>
</div>
<p>
<code>sprintf</code> formats the arguments in <code>arg1, arg2</code>, etc., according to <code>format</code> as before, but places the result in <code>string</code> instead of the standard output; <code>string</code> must be big enough to receive the result.<br />
</p>
</div>
</div>


<div id="outline-container-orgd54c27f" class="outline-3">
<h3 id="orgd54c27f"><span class="section-number-3">7.3</span> Variable-length Argument Lists</h3>
<div class="outline-text-3" id="text-7-3">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">void</span> <span style="color: #00ff7f;">minprintf</span>(<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">fmt</span>, ...)
</pre>
</div>
<p>
The tricky bit is how <code>minprintf</code> walks along the arguments list when the list doesn't even have a name. The standard header <code>&lt;stdarg.h&gt;</code> contains a set of macro definitions that define how to step through an argument list. The implementation of this header will vary from machine to machine, but the interface it presents is uniform.<br />
</p>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdarg.h&gt;</span>

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">minprintf: minimal printf with variable argument list </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">void</span> <span style="color: #00ff7f;">minprintf</span>(<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">fmt</span>, ...)  <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">... </span><span style="color: #cd853f;">*/</span>
{
  <span style="color: #9370db;">va_list</span> <span style="color: #9acd32;">ap</span>;                   <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">point to each unnamed arg in turn </span><span style="color: #cd853f;">*/</span>
  <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">p</span>, *<span style="color: #9acd32;">sval</span>;
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">ival</span>;
  <span style="color: #9370db;">double</span> <span style="color: #9acd32;">dval</span>;

  va_start(ap, fmt);            <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">make ap point to 1st unnamed arg </span><span style="color: #cd853f;">*/</span>
  <span style="color: #20b2aa; font-weight: bold;">for</span> (p = fmt; *p; p++) {
    <span style="color: #20b2aa; font-weight: bold;">if</span> (*p != <span style="color: #ffa07a;">'%'</span>) {
      putchar(*p);              <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">no conversion </span><span style="color: #cd853f;">*/</span>
      <span style="color: #20b2aa; font-weight: bold;">continue</span>;
    }

    <span style="color: #cd853f;">/* </span>
<span style="color: #cd853f;">       Each call of va_arg returns one argument and</span>
<span style="color: #cd853f;">       steps ap to the next; va_arg uses a type name</span>
<span style="color: #cd853f;">       to determine what type to return and how big</span>
<span style="color: #cd853f;">       a step to take.</span>
<span style="color: #cd853f;">     </span><span style="color: #cd853f;">*/</span>
    <span style="color: #20b2aa; font-weight: bold;">switch</span> (*++p) {             <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">conversion </span><span style="color: #cd853f;">*/</span>
    <span style="color: #20b2aa; font-weight: bold;">case</span> <span style="color: #ffa07a;">'d'</span>:
      ival = va_arg(ap, <span style="color: #9370db;">int</span>);
      printf(<span style="color: #ffa07a;">"%d"</span>, ival);
      <span style="color: #20b2aa; font-weight: bold;">break</span>;
    <span style="color: #20b2aa; font-weight: bold;">case</span> <span style="color: #ffa07a;">'f'</span>:
      dval = va_arg(ap, <span style="color: #9370db;">double</span>);
      printf(<span style="color: #ffa07a;">"%f"</span>, dval);
      <span style="color: #20b2aa; font-weight: bold;">break</span>;
    <span style="color: #20b2aa; font-weight: bold;">case</span> <span style="color: #ffa07a;">'s'</span>:
      <span style="color: #20b2aa; font-weight: bold;">for</span> (sval = va_arg(ap, <span style="color: #9370db;">char</span> *); *sval; sval++)
        putchar(*sval);
      <span style="color: #20b2aa; font-weight: bold;">break</span>;
    <span style="color: #20b2aa; font-weight: bold;">default</span>:
      putchar(*p);
      <span style="color: #20b2aa; font-weight: bold;">break</span>;
    }
  }
  va_end(ap);                   <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">clean up when done </span><span style="color: #cd853f;">*/</span>
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org2b4e30e" class="outline-3">
<h3 id="org2b4e30e"><span class="section-number-3">7.4</span> Formatted Input -Scanf</h3>
<div class="outline-text-3" id="text-7-4">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #00ff7f;">scanf</span>(<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">format</span>, ...)
</pre>
</div>
<p>
<code>scanf</code> reads characters from the standard input, interprets them according to the specification in <code>format</code>, and stores the results through the remaining arguments. The other arguments, <b>each of which must be a pointer</b>, indicate where the corresponding converted input should be stored. <code>scanf</code> stops when it exhausts its format string, or when some input fails to match the control specification. It returns as its value the number of successfully matched and assigned input items. On the end of the file, EOF is returned. The next call to <code>scanf</code> resumes searching immediately after the last character already converted.<br />
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #00ff7f;">sscanf</span>(<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">string</span>, <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">format</span>, arg1, arg2, ...)
</pre>
</div>
<p>
It scans the <code>string</code> according to the format in <code>format</code> and stores the resulting values through <code>arg1, arg2</code>, etc. These arguments must be pointers.<br />
</p>

<pre class="example">
White space characters are blank, tab, newline, carriage return, vertical, and formfeed.
</pre>


<div class="figure">
<p><img src="pics/basic-scanf-conversion.png" alt="basic-scanf-conversion.png" /><br />
</p>
</div>

<p>
The conversion characters <code>d, i, o, u</code>, and <code>x</code> may be preceded by <code>h</code> to indicate that a pointer to <code>short</code> rather than <code>int</code> appears in the argument list, or by <code>l</code> to indicate that a pointer to <code>long</code> appears in the argument list.<br />
</p>

<hr />
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">main</span>(<span style="color: #9370db;">void</span>)
{
  <span style="color: #9370db;">double</span> <span style="color: #9acd32;">sum</span>, <span style="color: #9acd32;">v</span>;

  sum = 0;
  <span style="color: #20b2aa; font-weight: bold;">while</span>(scanf(<span style="color: #ffa07a;">"%lf"</span>, &amp;v) == 1)
    printf(<span style="color: #ffa07a;">"%\t%.2f\n"</span>, sum += v);
  <span style="color: #20b2aa; font-weight: bold;">return</span> 0;
}

</pre>
</div>
<hr />

<p>
<code>scanf</code> ignores blanks and tabs in its format string. Furthermore, it skips over white space as it looks for input values.<br />
</p>
</div>
</div>


<div id="outline-container-org252788f" class="outline-3">
<h3 id="org252788f"><span class="section-number-3">7.5</span> File Access</h3>
<div class="outline-text-3" id="text-7-5">
<p>
<code>getchar, putchar, printf, sprintf, scanf, sscanf</code> all read the standard input or write the standard output, which are automatically define for a program by the local operating system.<br />
</p>


<p>
How to write a program to access a file that it <b>not</b> already connnected to the program?<br />
For example:<br />
</p>
<div class="org-src-container">
<pre class="src src-sh">cat x.c y.c
</pre>
</div>
<p>
The rules are simple.<br />
Before it can be read or written, a file has to be <b>opened</b> by the library function <code>fopen</code>. <code>fopen</code> takes an external name like <code>x.c</code> or <code>y.c</code>, does some houskeeping and negoriation with the operating system, and returns a pointer to be used in subsequent reads or writes of the file.<br />
</p>

<p>
This pointer, called <b>file pointer</b>, points to a structure that contains information about the file, such as the location of a buffer, the current character position in the buffer, whether the file is being read or written, and whether errors or end of file have occurred. Users don't need to know the details, because the definitions obtained from <code>&lt;stdio.h&gt;</code> include a structure declaration called <code>FILE</code>. The only declaration needed for a file pointer is exemplified by<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">FILE</span> *<span style="color: #9acd32;">fp</span>;
<span style="color: #9370db;">FILE</span> *<span style="color: #00ff7f;">fopen</span>(<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">name</span>, <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">mode</span>);
</pre>
</div>
<p>
This says that <code>fp</code> is a pointer to a <code>FILE</code>, and <code>fopen</code> returns a pointer to a FILE. <code>FILE</code> is type name, like <code>int</code>, not a structure tag; it is defined with <code>typedef</code>.<br />
</p>

<p>
If a file that does not exist is opened for writing or appending, it is created if possible. Trying to read a file that does not exist is an error, and there may be other causes of error as well, like trying to read a file when you don't have permission. If there is any error, fopen will return NULL.<br />
</p>


<p>
The next thing needed is a way to read or write the file once it is open.<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #00ff7f;">getc</span>(<span style="color: #9370db;">FILE</span> *<span style="color: #9acd32;">fp</span>)
</pre>
</div>
<p>
<code>getc</code> returns the next character from the stream referred by <code>fp</code>; it returns <code>EOF</code> for end of file or error.<br />
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #00ff7f;">putc</span>(<span style="color: #9370db;">int</span> <span style="color: #9acd32;">c</span>, <span style="color: #9370db;">FILE</span> *<span style="color: #9acd32;">fp</span>)
</pre>
</div>
<p>
<code>putc</code> writes the character c to the file <code>fp</code> and returns the character written, or <code>EOF</code> if an error occurs.<br />
</p>

<p>
When a C program is started, the operating system environment is responsible for opening three files and providing pointers for them. These files are standard input, the standard output, and the standard error; the corresponding file pointers are called <code>stdin, stdout</code>, and <code>stderr</code>, and are declared in <code>&lt;stdio.h&gt;</code>. Normally <code>stdin</code> is connected to the keyboard and <code>stdout</code> and <code>stderr</code> are connected to the screen, but they may be redirected to files or pipes.<br />
</p>



<p>
<code>getchar</code> and <code>putchar</code> can be defined in terms of <code>getc, putc, stdin,</code> and <code>stdout</code> as follows:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#define</span> <span style="color: #00ff7f;">getchar</span>() getc(stdin)
<span style="color: #6495ed;">#define</span> <span style="color: #00ff7f;">putchar</span>(<span style="color: #9acd32;">c</span>) putc((c), stdout)
</pre>
</div>


<p>
For formatted input or output of files, the functions <code>fscanf</code> and <code>fprintf</code> may be used. These are identical to <code>scanf</code> and <code>printf</code>, except that the first argument is a file pointer that specifies the file to be read or written; the format string is the second argument.<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #00ff7f;">fscanf</span>(<span style="color: #9370db;">FILE</span> *<span style="color: #9acd32;">fp</span>, <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">format</span>, ...)
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">fprintf</span>(<span style="color: #9370db;">FILE</span> *<span style="color: #9acd32;">fp</span>, <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">format</span>, ...)
</pre>
</div>



<hr />
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">cat: concatenate files, version 1 </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">main</span>(<span style="color: #9370db;">int</span> <span style="color: #9acd32;">argc</span>, <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">argv</span>[])
{
  <span style="color: #9370db;">FILE</span> *<span style="color: #9acd32;">fp</span>;                     <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">file pointer </span><span style="color: #cd853f;">*/</span>
  <span style="color: #9370db;">void</span> <span style="color: #00ff7f;">filecopy</span>(<span style="color: #9370db;">FILE</span> *, <span style="color: #9370db;">FILE</span> *);

  <span style="color: #20b2aa; font-weight: bold;">if</span> (argc == 1)                <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">no args </span><span style="color: #cd853f;">*/</span>
    filecopy(stdin, stdout);
  <span style="color: #20b2aa; font-weight: bold;">else</span>
    <span style="color: #20b2aa; font-weight: bold;">while</span> (--argc &gt; 0)
      <span style="color: #20b2aa; font-weight: bold;">if</span> ((fp = fopen(*++argv, <span style="color: #ffa07a;">"r"</span>)) == <span style="color: #1e90ff;">NULL</span>) {
        printf(<span style="color: #ffa07a;">"cat: can't open %s\n"</span>, *argv);
        <span style="color: #20b2aa; font-weight: bold;">return</span> 1;
      } <span style="color: #20b2aa; font-weight: bold;">else</span> {
        filecopy(fp, stdout);
        fclose(fp);
      }
  <span style="color: #20b2aa; font-weight: bold;">return</span> 0;
}

<span style="color: #9370db;">void</span> <span style="color: #00ff7f;">filecopy</span>(<span style="color: #9370db;">FILE</span> *<span style="color: #9acd32;">ifp</span>, <span style="color: #9370db;">FILE</span> *<span style="color: #9acd32;">ofp</span>)
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">c</span>;

  <span style="color: #20b2aa; font-weight: bold;">while</span> ((c = getc(ifp)) != EOF)
    putc(c, ofp);
}

</pre>
</div>
<p>
The file pointers <code>stdin</code> and <code>stdout</code> are objects of type <code>FILE *</code>. They are constants, not variables, so it is not possible to assign to them.<br />
</p>

<p>
Since most operating systems have some limit on the number of files that a program may have open simultaneously, it's a good idea to free the file pointers when they are no longer needed, as we did in <code>cat</code>. <code>fclose</code> is called automatically for each open file when a program terminates normally. (You can close stdin and stdout if they are not needed. They can also be reassigned by the library function freopen.)<br />
</p>
</div>
</div>

<div id="outline-container-org02788e5" class="outline-3">
<h3 id="org02788e5"><span class="section-number-3">7.6</span> Error Handling - Stderr and Exit</h3>
<div class="outline-text-3" id="text-7-6">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">cat: concatenate files, version 2 </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">main</span>(<span style="color: #9370db;">int</span> <span style="color: #9acd32;">argc</span>, <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">argv</span>[])
{
  <span style="color: #9370db;">FILE</span> *<span style="color: #9acd32;">fp</span>;                     <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">file pointer </span><span style="color: #cd853f;">*/</span>
  <span style="color: #9370db;">void</span> <span style="color: #00ff7f;">filecopy</span>(<span style="color: #9370db;">FILE</span> *, <span style="color: #9370db;">FILE</span> *);
  <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">prog</span> = argv[0];         <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">program name for errors </span><span style="color: #cd853f;">*/</span>

  <span style="color: #20b2aa; font-weight: bold;">if</span> (argc == 1)                <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">no args </span><span style="color: #cd853f;">*/</span>
    filecopy(stdin, stdout);
  <span style="color: #20b2aa; font-weight: bold;">else</span>
    <span style="color: #20b2aa; font-weight: bold;">while</span> (--argc &gt; 0)
      <span style="color: #20b2aa; font-weight: bold;">if</span> ((fp = fopen(*++argv, <span style="color: #ffa07a;">"r"</span>)) == <span style="color: #1e90ff;">NULL</span>) {
        <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">we include the program name in the message</span>
<span style="color: #cd853f;">           so if this program is used with others,</span>
<span style="color: #cd853f;">           the source of an error is identified. </span><span style="color: #cd853f;">*/</span>
        fprintf(stderr, <span style="color: #ffa07a;">"%s: can't open %s\n"</span>, prog, *argv);
        <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">The argument of exit is available to</span>
<span style="color: #cd853f;">           whatever process called this one. </span><span style="color: #cd853f;">*/</span>
        exit(1);
      } <span style="color: #20b2aa; font-weight: bold;">else</span> {
        filecopy(fp, stdout);
        fclose(fp);
      }

  <span style="color: #20b2aa; font-weight: bold;">if</span> (ferror(stdout)) {
    fprintf(stderr, <span style="color: #ffa07a;">"%s: error writing stdout\n"</span>, prog);
    exit(2);
  }

  exit(0);
}

<span style="color: #9370db;">void</span> <span style="color: #00ff7f;">filecopy</span>(<span style="color: #9370db;">FILE</span> *<span style="color: #9acd32;">ifp</span>, <span style="color: #9370db;">FILE</span> *<span style="color: #9acd32;">ofp</span>)
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">c</span>;

  <span style="color: #20b2aa; font-weight: bold;">while</span> ((c = getc(ifp)) != EOF)
    putc(c, ofp);
}

</pre>
</div>

<p>
The argument of <code>exit</code> is available to whatever process called this one, so the success or failure of the program can be tested by another program that uses this one as a sub-process. <code>return expr</code> is equivalent to <code>exit(expr)</code>. <code>exit</code> has the advantage that it can be called from other functions, and that calls to it can be found with a pattern-searching program.<br />
</p>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #00ff7f;">ferror</span>(<span style="color: #9370db;">FILE</span> *<span style="color: #9acd32;">fp</span>)
</pre>
</div>
<p>
return non-zero if an error occurred on the stream <code>fp</code>.<br />
</p>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #00ff7f;">feof</span>(<span style="color: #9370db;">FILE</span> *<span style="color: #9acd32;">fp</span>) 
</pre>
</div>
<p>
returns non-zero if end of file has occurred on the specified file.<br />
</p>
</div>
</div>


<div id="outline-container-org010d435" class="outline-3">
<h3 id="org010d435"><span class="section-number-3">7.7</span> Line Input and Output</h3>
<div class="outline-text-3" id="text-7-7">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">char</span> *<span style="color: #00ff7f;">fgets</span>(<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">line</span>, <span style="color: #9370db;">int</span> <span style="color: #9acd32;">maxline</span>, <span style="color: #9370db;">FILE</span> *<span style="color: #9acd32;">fp</span>)
</pre>
</div>
<p>
reads the next input line (including the newline) from file <code>fp</code> into the character array <code>line</code>; at most <code>maxline-1</code> characters will be read. The resulting line is terminated with '\0'. Normally <code>fgets</code> returns line; on end of file or error it returns NULL.<br />
</p>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #00ff7f;">fputs</span>(<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">line</span>, <span style="color: #9370db;">FILE</span> *<span style="color: #9acd32;">fp</span>)
</pre>
</div>
<p>
writes a string (which need not contain a newline) to a file. It return EOF if an error occurs, and non-negative otherwise.<br />
</p>

<p>
The library functions <code>gets</code> and <code>puts</code> are similar to <code>fgets</code> and <code>fputs</code>, but operate on <code>stdin</code> and <code>stdout</code>. Confusingly, <code>gets</code> deletes the terminating '\n', and <code>puts</code> adds it.<br />
</p>

<hr />
<p>
SOURCE FILE:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #cd853f;">/* </span><span style="color: #cd853f;">fgets: get at most n chars from iop </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">char</span> *<span style="color: #00ff7f;">fgets</span>(<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">s</span>, <span style="color: #9370db;">int</span> <span style="color: #9acd32;">n</span>, <span style="color: #9370db;">FILE</span> *<span style="color: #9acd32;">iop</span>)
{
  <span style="color: #20b2aa; font-weight: bold;">register</span> <span style="color: #9370db;">int</span> <span style="color: #9acd32;">c</span>;
  <span style="color: #20b2aa; font-weight: bold;">register</span> <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">cs</span>;

  cs = s;
  <span style="color: #20b2aa; font-weight: bold;">while</span>(--n &gt; 0 &amp;&amp; (c = getc(iop)) != EOF)
    <span style="color: #20b2aa; font-weight: bold;">if</span> ((*cs++ = c) == <span style="color: #ffa07a;">'\n'</span>)
      <span style="color: #20b2aa; font-weight: bold;">break</span>;
  *cs = <span style="color: #ffa07a;">'\0'</span>;
  <span style="color: #20b2aa; font-weight: bold;">return</span> (c == EOF &amp;&amp; cs == s) ? <span style="color: #1e90ff;">NULL</span> : s;
}

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">fputs: put string s on file iop </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">fputs</span>(<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">s</span>, <span style="color: #9370db;">FILE</span> *<span style="color: #9acd32;">iop</span>)
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">c</span>;

  <span style="color: #20b2aa; font-weight: bold;">while</span> (c = *s++)
    putc(c, iop);
  <span style="color: #20b2aa; font-weight: bold;">return</span> ferror(iop) ? EOF : 0;
}

</pre>
</div>
</div>
</div>

<div id="outline-container-orgd73985b" class="outline-3">
<h3 id="orgd73985b"><span class="section-number-3">7.8</span> Miscellaneous Functions</h3>
<div class="outline-text-3" id="text-7-8">
</div>
<div id="outline-container-org8c88576" class="outline-4">
<h4 id="org8c88576"><span class="section-number-4">7.8.1</span> String Operations</h4>
<div class="outline-text-4" id="text-7-8-1">
<p>
&lt;string.h&gt;<br />
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">strcat(char *s, char *t)</td>
<td class="org-left">concatenate t to end of s</td>
</tr>

<tr>
<td class="org-left">strncat(char *s, char *t, int n)</td>
<td class="org-left">concatenate n characters of t to end of s</td>
</tr>

<tr>
<td class="org-left">strcmp(char *s, char *t)</td>
<td class="org-left">return negative, zero or positive for s&lt;t, s==t, s&gt;t</td>
</tr>

<tr>
<td class="org-left">strncmp(char *s, char *t, int n)</td>
<td class="org-left">same as strcmp but only in first n characters</td>
</tr>

<tr>
<td class="org-left">strcpy(char *s, char *t)</td>
<td class="org-left">copy t to s</td>
</tr>

<tr>
<td class="org-left">strncpy(char *s, char *t, int n)</td>
<td class="org-left">copy at most n characters of t to s</td>
</tr>

<tr>
<td class="org-left">strlen(char *s)</td>
<td class="org-left">return length of s</td>
</tr>

<tr>
<td class="org-left">strchr(char *s, int c)</td>
<td class="org-left">return pointer to first c in s, or NULL if not present</td>
</tr>

<tr>
<td class="org-left">strrchr(char *s, int c)</td>
<td class="org-left">return pointer to last c in s, or NULL if not present</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgdf4f689" class="outline-4">
<h4 id="orgdf4f689"><span class="section-number-4">7.8.2</span> Character Class Testing and Conversion</h4>
<div class="outline-text-4" id="text-7-8-2">
<p>
&lt;ctype.h&gt;<br />
c is a int that can be represented as an unsigned char or EOF.<br />
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">int isalpha(int c)</td>
<td class="org-left">non-zero if c is alphabetic, 0 if not</td>
</tr>

<tr>
<td class="org-left">int isupper(int c)</td>
<td class="org-left">non-zero if c is upper case, 0 if not</td>
</tr>

<tr>
<td class="org-left">int islower(int c)</td>
<td class="org-left">non-zero if c is lower case, 0 if not</td>
</tr>

<tr>
<td class="org-left">int isdigit(int c)</td>
<td class="org-left">non-zero if c is digit, 0 if not</td>
</tr>

<tr>
<td class="org-left">int isalnum(int c)</td>
<td class="org-left">non-zero if c isalpha(c) or isdigit(c), 0 if not</td>
</tr>

<tr>
<td class="org-left">int isspace(int c)</td>
<td class="org-left">non-zero if c is blank, tab, newline, return, formfeed, vertical tab</td>
</tr>

<tr>
<td class="org-left">int toupper(int c)</td>
<td class="org-left">return c converted to upper case</td>
</tr>

<tr>
<td class="org-left">int tolower(int c)</td>
<td class="org-left">return c converted to lower case</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org5748b17" class="outline-4">
<h4 id="org5748b17"><span class="section-number-4">7.8.3</span> Ungetc</h4>
<div class="outline-text-4" id="text-7-8-3">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #00ff7f;">ungetc</span>(<span style="color: #9370db;">int</span> <span style="color: #9acd32;">c</span>, <span style="color: #9370db;">FILE</span> *<span style="color: #9acd32;">fp</span>)
</pre>
</div>
<p>
pushes the character <code>c</code> back onto file <code>fp</code>, and returns either <code>c</code> or <code>EOF</code> for an error. Only one character of pushback is guaranteed per file.<br />
</p>
</div>
</div>

<div id="outline-container-org2b41226" class="outline-4">
<h4 id="org2b41226"><span class="section-number-4">7.8.4</span> Command Execution</h4>
<div class="outline-text-4" id="text-7-8-4">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #00ff7f;">system</span>(<span style="color: #9370db;">char</span> *)
</pre>
</div>
<p>
executes the command contained in the character string s, then resumes execution of the current program.<br />
</p>

<div class="org-src-container">
<pre class="src src-C">system(<span style="color: #ffa07a;">"date"</span>);
</pre>
</div>
<p>
causes the program <code>date</code> to be run; it prints the data and time of day on the standard output. <code>system</code> returns a system-dependent integer status from the command executed. In the UNIX system, the status return is the value returned by <code>exit</code>.<br />
</p>
</div>
</div>

<div id="outline-container-orgef3ae59" class="outline-4">
<h4 id="orgef3ae59"><span class="section-number-4">7.8.5</span> Storage Manegement</h4>
<div class="outline-text-4" id="text-7-8-5">
<p>
The function <code>malloc</code> and <code>calloc</code> obtain blocks of memory dynamically.<br />
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">void</span> *<span style="color: #00ff7f;">malloc</span>(<span style="color: #9370db;">size_t</span> <span style="color: #9acd32;">n</span>)
</pre>
</div>
<p>
returns a pointer to n bytes of uninitialized storage, or NULL if the request cannot be satisfied.<br />
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">void</span> *<span style="color: #00ff7f;">calloc</span>(<span style="color: #9370db;">size_t</span> <span style="color: #9acd32;">n</span>, <span style="color: #9370db;">size_t</span> <span style="color: #9acd32;">size</span>)
</pre>
</div>
<p>
returns a pointer to enough free space for an array of n objects of the specified size, or NULL if the request cannot be satisfied. The storage is initialized to zero.<br />
</p>

<p>
The pointer returned by <code>malloc</code> or <code>calloc</code> has the proper alignment for the object in question, but it must be cast into the appropriate types, as in<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> *<span style="color: #9acd32;">ip</span>;

ip = (<span style="color: #9370db;">int</span> *) <span style="color: #00ff7f;">calloc</span>(n, <span style="color: #20b2aa; font-weight: bold;">sizeof</span>(<span style="color: #9370db;">int</span>));
</pre>
</div>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">void</span> <span style="color: #00ff7f;">free</span>(<span style="color: #9370db;">void</span> *<span style="color: #9acd32;">ptr</span>)
</pre>
</div>
<p>
frees the space pointed to by <code>ptr</code>, where <code>ptr</code> was originally obtained by a call to <code>malloc</code> or <code>calloc</code>. There are no restrictions on the order in which space is freed, but it is a ghastly error to free something not obtained by calling <code>malloc</code> or <code>calloc</code>.<br />
</p>


<p>
It is also an error to use something after it has been freed. A typical but incorrect piece of code is this loop that frees items from a list:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">for</span> (p = head; p != <span style="color: #1e90ff;">NULL</span>; p = p-&gt;next)  <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">WRONG </span><span style="color: #cd853f;">*/</span>
    <span style="color: #00ff7f;">free</span>(p);
</pre>
</div>
<p>
The right way is to save whatever is needed before freeing<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">for</span> (p = head; p != <span style="color: #1e90ff;">NULL</span>; p = q) {
    q = p-&gt;next;
    free(p);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb87b9f0" class="outline-4">
<h4 id="orgb87b9f0"><span class="section-number-4">7.8.6</span> Mathematical Functions</h4>
<div class="outline-text-4" id="text-7-8-6">
<p>
&lt;math.h&gt;<br />
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">double sin(doube x)</td>
<td class="org-left">sine of x, x in radians</td>
</tr>

<tr>
<td class="org-left">double cos(double x)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">double atan(double y, double x)</td>
<td class="org-left">arctangent of y/x, in radians</td>
</tr>

<tr>
<td class="org-left">double exp(double x)</td>
<td class="org-left">exponential function \(e^x\)</td>
</tr>

<tr>
<td class="org-left">double log(double x)</td>
<td class="org-left">natural (base e) logarithm of x</td>
</tr>

<tr>
<td class="org-left">double log10(double x)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">double pow(double x, double y)</td>
<td class="org-left">\(x^y\)</td>
</tr>

<tr>
<td class="org-left">double sqrt(double x)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">double fabs(double x)</td>
<td class="org-left">absolute value of x</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-org8fe15dc" class="outline-4">
<h4 id="org8fe15dc"><span class="section-number-4">7.8.7</span> Random Number Generation</h4>
<div class="outline-text-4" id="text-7-8-7">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #cd853f;">// </span><span style="color: #cd853f;">&lt;stdlib.h&gt;</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">rand</span>(<span style="color: #9370db;">void</span>)
</pre>
</div>
<p>
computes a sequence of pseudo-random integers in the range zero to <code>RAND_MAX</code>.<br />
</p>

<p>
To produce random floating-point numbers greater than or equal to zero but less than one:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #cd853f;">// </span><span style="color: #cd853f;">if your library does not provides the function.</span>
<span style="color: #6495ed;">#define</span> <span style="color: #00ff7f;">frand</span>() ((<span style="color: #9370db;">double</span>) rand() / (RAND_MAX+1.0))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">void</span> <span style="color: #00ff7f;">srand</span>(<span style="color: #9370db;">unsigned</span> <span style="color: #9370db;">int</span> <span style="color: #9acd32;">seed</span>)
</pre>
</div>
<p>
sets the seed for <code>rand</code>.<br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org8bca6c7" class="outline-2">
<h2 id="org8bca6c7"><span class="section-number-2">8</span> The UNIX System Interface</h2>
<div class="outline-text-2" id="text-8">
<pre class="example">
The UNIX operating system provides its services through a set of system calls, which are in effect functions within the operating system that may be called by user programs. 
</pre>
</div>

<div id="outline-container-orgeeba70a" class="outline-3">
<h3 id="orgeeba70a"><span class="section-number-3">8.1</span> File Descriptors</h3>
<div class="outline-text-3" id="text-8-1">
<p>
In the UNIX operating system, all input and output is done by reading or writing files, because all peripheral devices, even keyboard and screen, are files in the file system. This means that a single homogeneous interface handles all communication between a program and peripheral devices.<br />
</p>


<p>
In the most general case, before you read and write a file, you must inform the system of your intent to do so, a process called <b>opening</b> the file. The system checks your right to do so and if all is well, returns to the program a small non-negative integer called a <b>file descriptor</b>. Whenever input or output is to be done on the file, the file descriptor is used instead of the name to identify the file. All information about an open file is maintained by the system; the user program refers to the file only by the file descriptor.<br />
</p>


<p>
Since input and output involving keyboard and screen is so common, special arrangements exist to make this convenient. When the command interpreter (the ``shell'') runs a program, three files are open, with file descriptors 0, 1, and 2, called the standard input, the standard output, and the standard error. If a program reads 0 and writes 1 and 2, it can do input and output without worrying about opening files.<br />
</p>

<p>
The user of a program can redirect I/O to and from files with &lt; and &gt;:<br />
</p>
<div class="org-src-container">
<pre class="src src-sh">prog &lt; file &gt; outfile
</pre>
</div>
<p>
In this case, the shell changes the default assignments for the file descriptors 0 and 1 to the named files. Normally file descriptor 2 remains attached to the screen, so error messages can go there. Similar observations hold for input or output associated with a pipe. In all cases, the file assignments are changed by the shell, not by the program. The program does not know where its input comes from nor where its output goes, so long as it uses file 0 for input and 1 and 2 for output.<br />
</p>
</div>
</div>


<div id="outline-container-orgb011d70" class="outline-3">
<h3 id="orgb011d70"><span class="section-number-3">8.2</span> Low Level I/O - Read and Write</h3>
<div class="outline-text-3" id="text-8-2">
<p>
Input and output uses the <code>read</code> and <code>write</code> system calls, which are accessed from C programs through two functions called <code>read</code> and <code>write</code>.<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #9acd32;">n_read</span> = read(<span style="color: #9370db;">int</span> <span style="color: #9acd32;">fd</span>, <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">buf</span>, <span style="color: #9370db;">int</span> <span style="color: #9acd32;">n</span>);
<span style="color: #9370db;">int</span> <span style="color: #9acd32;">n_written</span> = write(<span style="color: #9370db;">int</span> <span style="color: #9acd32;">fd</span>, <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">buf</span>, <span style="color: #9370db;">int</span> <span style="color: #9acd32;">n</span>);
</pre>
</div>
<p>
The first argument is a file descriptor. The second argument is a character array in your program where the data is to go to or come from. The third argument is the number of bytes to be transferred. Each call returns a count of the number of bytes tranferred. On reading, the number of bytes returned may be less than the number requested. A return value of zero bytes implies end of file, and -1 indicates an error of some sort. For writing, the return value is the number of bytes written; an error has occurred if this isn't equal to the number requested.<br />
</p>

<hr />
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">"syscalls.h"</span>

<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">main</span>(<span style="color: #9370db;">void</span>)                  <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">copy input to output </span><span style="color: #cd853f;">*/</span>
{
  <span style="color: #9370db;">char</span> <span style="color: #9acd32;">buf</span>[BUFSIZ];
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">n</span>;

  <span style="color: #20b2aa; font-weight: bold;">while</span> ((n = read(0, buf, BUFSIZ)) &gt; 0)
    write(1, buf, n);
  <span style="color: #20b2aa; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">"syscalls.h"</span>

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">getchar: unbuffered single character input </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">getchar</span>(<span style="color: #9370db;">void</span>)
{
  <span style="color: #9370db;">char</span> <span style="color: #9acd32;">c</span>;

  <span style="color: #20b2aa; font-weight: bold;">return</span> (read(0, &amp;c, 1) == 1) ? (<span style="color: #9370db;">unsigned</span> <span style="color: #9370db;">char</span>) c : EOF;
}

</pre>
</div>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">"syscalls.h"</span>

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">getchar: simple buffered version </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">getchar</span>(<span style="color: #9370db;">void</span>)
{
  <span style="color: #20b2aa; font-weight: bold;">static</span> <span style="color: #9370db;">char</span> <span style="color: #9acd32;">buf</span>[BUFSIZ];
  <span style="color: #20b2aa; font-weight: bold;">static</span> <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">bufp</span> = buf;
  <span style="color: #20b2aa; font-weight: bold;">static</span> <span style="color: #9370db;">int</span> <span style="color: #9acd32;">n</span> = 0;

  <span style="color: #20b2aa; font-weight: bold;">if</span> (n == 0) {                 <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">buffer is empty </span><span style="color: #cd853f;">*/</span>
    n = read(0, buf, <span style="color: #20b2aa; font-weight: bold;">sizeof</span> buf);
    bufp = buf;
  }

  <span style="color: #20b2aa; font-weight: bold;">return</span> (--n &gt;= 0) ? (<span style="color: #9370db;">unsigned</span> <span style="color: #9370db;">char</span>) *bufp++ : EOF;
  <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">bufp++, continue the reading. </span><span style="color: #cd853f;">*/</span>
  <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">--n: '\0' </span><span style="color: #cd853f;">*/</span>
}

</pre>
</div>

<hr />
</div>
</div>


<div id="outline-container-org109ce11" class="outline-3">
<h3 id="org109ce11"><span class="section-number-3">8.3</span> Open, Create, Close, Unlink</h3>
<div class="outline-text-3" id="text-8-3">
<p>
Other than the default standard input, output and error, you must explicitly open files in order to read or write them. There are two system calls for this, <code>open</code> and <code>creat</code>.<br />
</p>

<p>
<code>open</code> is rather like the <code>fopen</code>, except that instead of returning a file pointer, it returns a file descriptor, which is just an <code>int</code>. open returns -1 if any error occurs.<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;fcntl.h&gt;</span>

<span style="color: #9370db;">int</span> <span style="color: #9acd32;">fd</span>;
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">open</span>(<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">name</span>, <span style="color: #9370db;">int</span> <span style="color: #9acd32;">flags</span>, <span style="color: #9370db;">int</span> <span style="color: #9acd32;">perms</span>);

fd = open(name, flags, perms);
</pre>
</div>
<p>
As with <code>fopen</code>, the <code>name</code> argument is a character string containing the filename. The second argument, <code>flags</code>, is an <code>int</code> that specifies how the file is to be opened; the main values are<br />
</p>
<dl class="org-dl">
<dt>O_RDONLY</dt><dd>open for reading only<br /></dd>
<dt>O_WRONLY</dt><dd>open for writting only<br /></dd>
<dt>O_RDWR</dt><dd>open for both reading and writing<br /></dd>
</dl>

<p>
These constants are defined in &lt;fcntl.h&gt; on System V UNIX systems, and in &lt;sys/file.h&gt; on Berkeley(BSD) versions.<br />
</p>
<div class="org-src-container">
<pre class="src src-C">fd = open(name, O_RDONLY, 0);
</pre>
</div>
<p>
The <code>perms</code> argument is always zero for the uses of <code>open</code>.<br />
</p>


<p>
It is an error to try to open a file that does not exist. The system call <code>creat</code> is provided to create new files, or to re-write old ones.<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #00ff7f;">creat</span>(<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">name</span>, <span style="color: #9370db;">int</span> <span style="color: #9acd32;">perms</span>);

fd = creat(name, perms);
</pre>
</div>
<p>
returns a file descriptor if it was able to create the file, and -1 if not. If the file already exists, creat will truncate it to zero length, thereby discarding its previous contents; it is not an error to <code>creat</code> a file that already exists.<br />
</p>

<p>
If the file does not already exist, creat creates it with the permissions specified by the perms argument.<br />
</p>


<hr />
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;fcntl.h&gt;</span>
<span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">"syscalls.h"</span>
<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">PERMS</span> 0666              <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">RW for owner, group, others </span><span style="color: #cd853f;">*/</span>

<span style="color: #9370db;">void</span> <span style="color: #00ff7f;">error</span>(<span style="color: #9370db;">char</span> *, ...);

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">cp: copy f1 to f2 </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">main</span>(<span style="color: #9370db;">int</span> <span style="color: #9acd32;">argc</span>, <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">argv</span>[])
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">f1</span>, <span style="color: #9acd32;">f2</span>, <span style="color: #9acd32;">n</span>;
  <span style="color: #9370db;">char</span> <span style="color: #9acd32;">buf</span>[BUFSIZ];

  <span style="color: #20b2aa; font-weight: bold;">if</span> (argc != 3)
    error(<span style="color: #ffa07a;">"Usage: cp from to"</span>);

  <span style="color: #20b2aa; font-weight: bold;">if</span> ((f1 = open(argv[1], O_RDONLY, 0)) == -1)
    error(<span style="color: #ffa07a;">"cp: can't open %s"</span>, argv[1]);

  <span style="color: #20b2aa; font-weight: bold;">if</span> ((f2 = creat(argv[2], PERMS)) == -1)
    error(<span style="color: #ffa07a;">"cp: can't create %s, mode %03o"</span>, argv[2], PERMS);

  <span style="color: #20b2aa; font-weight: bold;">while</span> ((n = read(f1, buf, BUFSIZ)) &gt; 0)
    <span style="color: #20b2aa; font-weight: bold;">if</span> (write(f2, buf, n) != n)
      error(<span style="color: #ffa07a;">"cp: write error on file %s"</span>, argv[2]);

  <span style="color: #20b2aa; font-weight: bold;">return</span> 0;
}

</pre>
</div>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdarg.h&gt;</span>

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">error: print an error message and die </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">void</span> <span style="color: #00ff7f;">error</span>(<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">fmt</span>, ...)
{
  <span style="color: #9370db;">va_list</span> <span style="color: #9acd32;">args</span>;

  va_start(args, fmt);
  fprintf(stderr, <span style="color: #ffa07a;">"error: "</span>);
  vprintf(stderr, fmt, args);
  fprintf(stderr, <span style="color: #ffa07a;">"\n"</span>);
  va_end(args);
  exit(1);
}

</pre>
</div>

<hr />


<p>
There is a limit (often about 20) on the number of files that a program may open simultaneously. Accordingly, any program that intends to process many files must be prepared to re-use file descriptors. The function <code>close(int fd)</code> breaks the connection between a file descriptor and an open file, and frees the file descriptor for use with some other file; it corresponds to <code>fclose</code> in the standard library except that there is no buffer to flush. Termination of a program via <code>exit</code> or return from the main program closes all open files.<br />
</p>



<p>
The function <code>unlink(char *name)</code> removes the file <code>name</code> from the file system. It corresponds to the standard library function <code>remove</code>.<br />
</p>
</div>
</div>

<div id="outline-container-org20f011b" class="outline-3">
<h3 id="org20f011b"><span class="section-number-3">8.4</span> Random Access -Lseek</h3>
<div class="outline-text-3" id="text-8-4">
<p>
Input and output are normally sequential: each read or write takes place at a position in the file right after the previous one. When necessary, however, a file can be read or written in any arbitrary order. The system call <code>lseek</code> provides a way to move around in a file without reading or writing any data:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">long</span> <span style="color: #00ff7f;">lseek</span>(<span style="color: #9370db;">int</span> <span style="color: #9acd32;">fd</span>, <span style="color: #9370db;">long</span> <span style="color: #9acd32;">offset</span>, <span style="color: #9370db;">int</span> <span style="color: #9acd32;">origin</span>);
</pre>
</div>
<p>
sets the current position in the file whose descriptor is <code>fd</code> to <code>offset</code>, which is taken relative to the location specified by <code>origin</code>. Subsequent reading and writing will begin at that position. <code>origin</code> can be 0, 1, or 2 to specify that <code>offset</code> is to be measured from the beginning, from the current position, or from the end of the file respectively.<br />
</p>

<hr />
<p>
To append to a file (the redirection &gt;&gt; in the UNIX shell, or "a" for fopen), seek to the end before writing:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00ff7f;">lseek</span>(fd, 0L, 2);
</pre>
</div>

<p>
To get back to the beginning:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00ff7f;">lseek</span>(fd, 0L, 0);
</pre>
</div>

<hr />

<p>
With lseek, it is possible to treat files more or less like arrays, at the price of slower access.<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">"syscalls.h"</span>

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">get: read n byptes from position pos </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">get</span>(<span style="color: #9370db;">int</span> <span style="color: #9acd32;">fd</span>, <span style="color: #9370db;">long</span> <span style="color: #9acd32;">pos</span>, <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">buf</span>, <span style="color: #9370db;">int</span> <span style="color: #9acd32;">n</span>)
{
  <span style="color: #20b2aa; font-weight: bold;">if</span> (lseek(fd, pos, 0) &gt;= 0)   <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">get to pos </span><span style="color: #cd853f;">*/</span>
    <span style="color: #20b2aa; font-weight: bold;">return</span> read(fd, buf, n);
  <span style="color: #20b2aa; font-weight: bold;">else</span>
    <span style="color: #20b2aa; font-weight: bold;">return</span> -1;
}
</pre>
</div>

<p>
The standard library function <code>fseek</code> <br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #9370db;">int</span> <span style="color: #00ff7f;">fseek</span>(<span style="color: #9370db;">FILE</span> *<span style="color: #9acd32;">fp</span>, <span style="color: #9370db;">long</span> <span style="color: #9acd32;">offset</span>, <span style="color: #9370db;">int</span> <span style="color: #9acd32;">origin</span>);
</pre>
</div>
<p>
is similar to <code>lseek</code> except that the first argument is a FILE * and the return is non-zero if an error occurred.<br />
</p>
</div>
</div>



<div id="outline-container-org9a8f834" class="outline-3">
<h3 id="org9a8f834"><span class="section-number-3">8.5</span> Example - An Implementation of fopen</h3>
<div class="outline-text-3" id="text-8-5">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #cd853f;">/* </span><span style="color: #cd853f;">Names that are intended for use only by functions of the library</span>
<span style="color: #cd853f;">   begin with an underscore so thay are less likely to conclide</span>
<span style="color: #cd853f;">   with names in a user's program. This convetion is used by</span>
<span style="color: #cd853f;">   all standard library routines. </span><span style="color: #cd853f;">*/</span>
<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">NULL</span> 0
<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">EOF</span> (-1)
<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">BUFSIZ</span> 1024
<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">OPEN_MAX</span> 20             <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">max #files open at once </span><span style="color: #cd853f;">*/</span>

<span style="color: #20b2aa; font-weight: bold;">typedef</span> <span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">_iobuf</span> {
    <span style="color: #9370db;">int</span> <span style="color: #9acd32;">cnt</span>;                    <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">characters left </span><span style="color: #cd853f;">*/</span>
    <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">ptr</span>;                  <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">next character position </span><span style="color: #cd853f;">*/</span>
    <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">base</span>;                 <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">location of buffer </span><span style="color: #cd853f;">*/</span>
    <span style="color: #9370db;">int</span> <span style="color: #9acd32;">flag</span>;                   <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">mode of file access </span><span style="color: #cd853f;">*/</span>
    <span style="color: #9370db;">int</span> <span style="color: #9acd32;">fd</span>;                     <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">file descriptor </span><span style="color: #cd853f;">*/</span>
} <span style="color: #9370db;">FILE</span>;
<span style="color: #20b2aa; font-weight: bold;">extern</span> <span style="color: #9370db;">FILE</span> <span style="color: #9acd32;">_iob</span>[OPEN_MAX];     <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">input output buffer </span><span style="color: #cd853f;">*/</span>

<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">stdin</span> (&amp;_iob[0])
<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">stdout</span> (&amp;_iob[1])
<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">stderr</span> (&amp;_iob[2])

<span style="color: #20b2aa; font-weight: bold;">enum</span> <span style="color: #9370db;">_flags</span> {
    <span style="color: #9acd32;">_READ</span> = 01, <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">file open for reading </span><span style="color: #cd853f;">*/</span>
    <span style="color: #9acd32;">_WRITE</span> = 02,        <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">file open for writing </span><span style="color: #cd853f;">*/</span>
    <span style="color: #9acd32;">_UNBUF</span> = 04,        <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">file is unbuffered </span><span style="color: #cd853f;">*/</span>
    <span style="color: #9acd32;">_EOF</span> = 010, <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">EOF has occurred on this file </span><span style="color: #cd853f;">*/</span>
    <span style="color: #9acd32;">_ERR</span> = 020          <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">error occurred on this file </span><span style="color: #cd853f;">*/</span>
};

<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">_fillbuf</span>(<span style="color: #9370db;">FILE</span> *);
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">_flushbuf</span>(<span style="color: #9370db;">int</span>, <span style="color: #9370db;">FILE</span> *);

<span style="color: #6495ed;">#define</span> <span style="color: #00ff7f;">feof</span>(<span style="color: #9acd32;">p</span>) ((p)-&gt;flag &amp; _EOF) != 0)
<span style="color: #6495ed;">#define</span> <span style="color: #00ff7f;">ferror</span>(<span style="color: #9acd32;">p</span>) ((p)-&gt;flag &amp; _ERR != 0)
<span style="color: #6495ed;">#define</span> <span style="color: #00ff7f;">fileno</span>(<span style="color: #9acd32;">p</span>) ((p)-&gt;fd)
<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">if there are still characters to be read, get one character more </span><span style="color: #cd853f;">*/</span>
<span style="color: #6495ed;">#define</span> <span style="color: #00ff7f;">getc</span>(<span style="color: #9acd32;">p</span>) (--(p)-&gt;cnt &gt;= 0 ? (<span style="color: #9370db;">unsigned</span> <span style="color: #9370db;">char</span>) *(p)-&gt;ptr++ : _fillbuf(p))
<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">if there are still character to be written, put one character more </span><span style="color: #cd853f;">*/</span>
<span style="color: #6495ed;">#define</span> <span style="color: #00ff7f;">putc</span>(<span style="color: #9acd32;">x</span>,<span style="color: #9acd32;">p</span>) (--(p)-&gt;cnt &gt;= 0 ? *(p)-&gt;ptr++ = (x) : _flushbuf((x),p))
<span style="color: #6495ed;">#define</span> <span style="color: #00ff7f;">getchar</span>() getc(stdin)
<span style="color: #6495ed;">#define</span> <span style="color: #00ff7f;">putchar</span>(<span style="color: #9acd32;">x</span>) putc((x), stdout)


<span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;fcntl.h&gt;</span>
<span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">"syscalls.h"</span>
<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">PERMS</span> 0666

<span style="color: #9370db;">FILE</span> *<span style="color: #00ff7f;">fopen</span>(<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">name</span>, <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">mode</span>)
{
    <span style="color: #9370db;">int</span> <span style="color: #9acd32;">fd</span>;
    <span style="color: #9370db;">FILE</span> *<span style="color: #9acd32;">fp</span>;

    <span style="color: #20b2aa; font-weight: bold;">if</span> (*mode != <span style="color: #ffa07a;">'r'</span> &amp;&amp; *mode != <span style="color: #ffa07a;">'w'</span> &amp;&amp; *mode != <span style="color: #ffa07a;">'a'</span>)
        <span style="color: #20b2aa; font-weight: bold;">return</span> <span style="color: #1e90ff;">NULL</span>;

    <span style="color: #20b2aa; font-weight: bold;">for</span> (fp = _iob; fp &lt; _iob + OPEN_MAX; fp++)
        <span style="color: #20b2aa; font-weight: bold;">if</span> ((fp-&gt;flag &amp; (_READ | _WRITE)) == 0)
            <span style="color: #20b2aa; font-weight: bold;">break</span>;                      <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">found free slot </span><span style="color: #cd853f;">*/</span>

    <span style="color: #20b2aa; font-weight: bold;">if</span> (fp &gt;= _iob + OPEN_MAX)  <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">no free slots </span><span style="color: #cd853f;">*/</span>
        <span style="color: #20b2aa; font-weight: bold;">return</span> <span style="color: #1e90ff;">NULL</span>;

    <span style="color: #20b2aa; font-weight: bold;">if</span> (*mode == <span style="color: #ffa07a;">'w'</span>)
        fd = creat(name, PERMS);
    <span style="color: #20b2aa; font-weight: bold;">else</span> <span style="color: #20b2aa; font-weight: bold;">if</span> (*mode == <span style="color: #ffa07a;">'a'</span>) {
        <span style="color: #20b2aa; font-weight: bold;">if</span> ((fd = open(name, O_WRONLY, 0)) == -1)
            fd = creat(name, PERMS);
        lseek(fd, 0L, 2);
    } <span style="color: #20b2aa; font-weight: bold;">else</span>
        fd = open(name, O_RDONLY, 0);

    <span style="color: #20b2aa; font-weight: bold;">if</span> (fd == -1)               <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">couldn't access name </span><span style="color: #cd853f;">*/</span>
        reutrn <span style="color: #1e90ff;">NULL</span>;

    fp-&gt;fd = fd;
    fp-&gt;cnt = 0;
    fp-&gt;base = <span style="color: #1e90ff;">NULL</span>;
    fp-&gt;flag = (*mode == <span style="color: #ffa07a;">'r'</span>) ? _READ : _WRITE;

    <span style="color: #20b2aa; font-weight: bold;">return</span> fp;
}

</pre>
</div>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">"syscalls.h"</span>


<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">_fillbuf: allocate and fill input buffer </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">_fillbuf</span>(<span style="color: #9370db;">FILE</span> *<span style="color: #9acd32;">fp</span>)
{
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">bufsize</span>;

  <span style="color: #20b2aa; font-weight: bold;">if</span> ((fp-&gt;flag &amp; (_READ | _EOF_ERR)) != _READ) <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">end of file </span><span style="color: #cd853f;">*/</span>
    <span style="color: #20b2aa; font-weight: bold;">return</span> EOF;

  bufsize = (fp-&gt;flag &amp; _UNBUF) ? 1 : BUFSIZ; <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">buffered or not </span><span style="color: #cd853f;">*/</span>

  fp-&gt;ptr = fp-&gt;base;           <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">point to the location of buffer </span><span style="color: #cd853f;">*/</span>
  <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">read bufsize bytes and update the count </span><span style="color: #cd853f;">*/</span>
  fp-&gt;cnt = read(fp-&gt;fd, fp-&gt;ptr, bufsize);

  <span style="color: #20b2aa; font-weight: bold;">if</span> (--fp-&gt;cnt &lt; 0) {          <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">if there are no characters left to read </span><span style="color: #cd853f;">*/</span>
    <span style="color: #20b2aa; font-weight: bold;">if</span> (fp-&gt;cnt == -1)          <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">end of file </span><span style="color: #cd853f;">*/</span>
      fp-&gt;flag |= _EOF;
    <span style="color: #20b2aa; font-weight: bold;">else</span>                        <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">error </span><span style="color: #cd853f;">*/</span>
      fp-&gt;flag |= _ERR;
    fp-&gt;cnt = 0;                <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">no more character to read </span><span style="color: #cd853f;">*/</span>
    <span style="color: #20b2aa; font-weight: bold;">return</span> EOF;
  }
  <span style="color: #20b2aa; font-weight: bold;">return</span> (<span style="color: #9370db;">unsigned</span> <span style="color: #9370db;">char</span>) *fp-&gt;ptr++; <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">return the next character </span><span style="color: #cd853f;">*/</span>
}


<span style="color: #9370db;">FILE</span> <span style="color: #9acd32;">_iob</span>[OPEN_MAX] = {
                       <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">count, ptr, base, flag, fd </span><span style="color: #cd853f;">*/</span>
                       { 0, (<span style="color: #9370db;">char</span> *) 0, (<span style="color: #9370db;">char</span> *) 0, _READ, 0 },
                       { 0, (<span style="color: #9370db;">char</span> *) 0, (<span style="color: #9370db;">char</span> *) 0, _WRITE, 1 },
                       { 0, (<span style="color: #9370db;">char</span> *) 0, (<span style="color: #9370db;">char</span> *) 0, _WRITE | _UNBUF, 2 }
};

</pre>
</div>
</div>
</div>

<div id="outline-container-org145be02" class="outline-3">
<h3 id="org145be02"><span class="section-number-3">8.6</span> Example - Listing Directories</h3>
<div class="outline-text-3" id="text-8-6">
<p>
In the UNIX file system, a directory is a file that constains a list of filenames and some indication of where they are located. The "location" is an index into another table called the "inode list". The inode for a file is where all information about the file except its name is kept. A directory entry generally consists of only two items, the filename and an inode number.<br />
</p>

<p>
dirent.h:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">NAME_MAX</span> 14             <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">longest filename component; system-dependent </span><span style="color: #cd853f;">*/</span>

<span style="color: #20b2aa; font-weight: bold;">typedef</span> <span style="color: #20b2aa; font-weight: bold;">struct</span> {                <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">portable directory entry </span><span style="color: #cd853f;">*/</span>
  <span style="color: #9370db;">long</span> <span style="color: #9acd32;">ino</span>;                     <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">inode number </span><span style="color: #cd853f;">*/</span>
  <span style="color: #9370db;">char</span> <span style="color: #9acd32;">name</span>[NAME_MAX+1];        <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">name + '\0' terminator </span><span style="color: #cd853f;">*/</span>
} <span style="color: #9370db;">Dirent</span>;

<span style="color: #20b2aa; font-weight: bold;">typedef</span> <span style="color: #20b2aa; font-weight: bold;">struct</span> {
  <span style="color: #9370db;">int</span> <span style="color: #9acd32;">fd</span>;                       <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">file descriptor for the directory </span><span style="color: #cd853f;">*/</span>
  <span style="color: #9370db;">Dirent</span> <span style="color: #9acd32;">d</span>;                     <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">the directory entry </span><span style="color: #cd853f;">*/</span>
} <span style="color: #9370db;">DIR</span>;

<span style="color: #9370db;">DIR</span> *<span style="color: #00ff7f;">opendir</span>(<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">dirname</span>);
<span style="color: #9370db;">Dirent</span> *<span style="color: #00ff7f;">readdir</span>(<span style="color: #9370db;">DIR</span> *<span style="color: #9acd32;">dfd</span>);
<span style="color: #9370db;">void</span> <span style="color: #00ff7f;">closedir</span>(<span style="color: #9370db;">DIR</span> *<span style="color: #9acd32;">dfd</span>);

</pre>
</div>

<p>
The system call <code>stat</code> takes a filename and returns all of the information in the inode for that file or -1 if there is an error.<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">stat</span> {                 <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">inode information returned by stat </span><span style="color: #cd853f;">*/</span>
  <span style="color: #9370db;">dev_t</span> <span style="color: #9acd32;">st_dev</span>;               <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">device of inode </span><span style="color: #cd853f;">*/</span>
  <span style="color: #9370db;">ino_t</span> <span style="color: #9acd32;">st_ino</span>;               <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">inode number </span><span style="color: #cd853f;">*/</span>
  <span style="color: #9370db;">short</span> <span style="color: #9acd32;">st_mode</span>;              <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">mode bits </span><span style="color: #cd853f;">*/</span>
  <span style="color: #9370db;">short</span> <span style="color: #9acd32;">st_nlink</span>;             <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">number of links to file </span><span style="color: #cd853f;">*/</span> 
  <span style="color: #9370db;">short</span> <span style="color: #9acd32;">st_uid</span>;               <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">owners user id </span><span style="color: #cd853f;">*/</span>
  <span style="color: #9370db;">short</span> <span style="color: #9acd32;">st_gid</span>;               <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">owners group id </span><span style="color: #cd853f;">*/</span>    
  <span style="color: #9370db;">dev_t</span> <span style="color: #9acd32;">st_rdev</span>;              <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">for special files </span><span style="color: #cd853f;">*/</span>
  <span style="color: #9370db;">off_t</span> <span style="color: #9acd32;">st_size</span>;              <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">file size in characters </span><span style="color: #cd853f;">*/</span> 
  <span style="color: #9370db;">time_t</span> <span style="color: #9acd32;">st_atime</span>;            <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">time last accessed </span><span style="color: #cd853f;">*/</span>
  <span style="color: #9370db;">time_t</span> <span style="color: #9acd32;">st_mtime</span>;            <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">time last modified </span><span style="color: #cd853f;">*/</span> 
  <span style="color: #9370db;">time_t</span> <span style="color: #9acd32;">st_ctime</span>;            <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">time originally created </span><span style="color: #cd853f;">*/</span>
};
</pre>
</div>

<p>
The types like <code>dev_t</code> and <code>ino_t</code> are defined in &lt;sys/types.h&gt;, which must be include too.<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">S_IFMT</span>
<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">S_IFDIR</span>
<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">S_IFCHR</span>
<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">S_IFBLK</span>
<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">S_IFREG</span>
0160000                         <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">type of file: </span><span style="color: #cd853f;">*/</span>
0040000                         <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">directory </span><span style="color: #cd853f;">*/</span>
0020000                         <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">character special </span><span style="color: #cd853f;">*/</span>
0060000                         <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">block special </span><span style="color: #cd853f;">*/</span>
0010000                         <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">regular </span><span style="color: #cd853f;">*/</span>
<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">... </span><span style="color: #cd853f;">*/</span>
</pre>
</div>


<p>
fsize.c:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #cd853f;">/* </span>
<span style="color: #cd853f;">   fsize is a special form of ls that prints the sizes of all files named in its commandline argument list.</span>
<span style="color: #cd853f;">   If one of the files is a directory, fsize applies itself recursively to that directory.</span>
<span style="color: #cd853f;">   If there are no arguments at all, it processes the current directory.</span>
<span style="color: #cd853f;">*/</span>
<span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>
<span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">"syscalls.h"</span>
<span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;fcntl.h&gt;</span>              <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">flags for read and write </span><span style="color: #cd853f;">*/</span>
<span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>          <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">typedefs </span><span style="color: #cd853f;">*/</span>
<span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;sys/stat.h&gt;</span>           <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">structure returned by stat </span><span style="color: #cd853f;">*/</span>
<span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">"dirent.h"</span>

<span style="color: #9370db;">void</span> <span style="color: #00ff7f;">fsize</span>(<span style="color: #9370db;">char</span> *);

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">print file names </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">main</span>(<span style="color: #9370db;">int</span> <span style="color: #9acd32;">argc</span>, <span style="color: #9370db;">char</span> **<span style="color: #9acd32;">argv</span>)
{
  <span style="color: #20b2aa; font-weight: bold;">if</span> (argc == 1)                <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">default: current directory </span><span style="color: #cd853f;">*/</span>
    fsize(<span style="color: #ffa07a;">"."</span>);
  <span style="color: #20b2aa; font-weight: bold;">else</span>
    <span style="color: #20b2aa; font-weight: bold;">while</span> (--argc &gt; 0)
      fize(*++argv);
  <span style="color: #20b2aa; font-weight: bold;">return</span> 0;
}

<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">stat</span>(<span style="color: #9370db;">char</span> *, <span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">stat</span> *);
<span style="color: #9370db;">void</span> <span style="color: #00ff7f;">dirwalk</span>(<span style="color: #9370db;">char</span> *, <span style="color: #9370db;">void</span> (*<span style="color: #00ff7f;">fcn</span>)(<span style="color: #9370db;">char</span> *));

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">fsize: print the name of file "name" </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">void</span> <span style="color: #00ff7f;">fsize</span>(<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">name</span>)
{
  <span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">stat</span> <span style="color: #9acd32;">stbuf</span>;

  <span style="color: #20b2aa; font-weight: bold;">if</span> (stat(name, &amp;stbuf) == -1) {
    fprintf(stderr, <span style="color: #ffa07a;">"fsize: can't access %s\n"</span>, name);
    <span style="color: #20b2aa; font-weight: bold;">return</span>;
  }

  <span style="color: #20b2aa; font-weight: bold;">if</span> ((stbuf.st_mode &amp; S_IFMT) == S_IFDIR) <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">directory </span><span style="color: #cd853f;">*/</span>
    dirwalk(name, fsize);
  printf(<span style="color: #ffa07a;">"%8ld %s\n"</span>, stbuf.st_size, name);
}

<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">MAX_PATH</span> 1024

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">dirwalk: apply fcn to call files in dir </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">void</span> <span style="color: #00ff7f;">dirwalk</span>(<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">dir</span>, <span style="color: #9370db;">void</span> (*<span style="color: #00ff7f;">fcn</span>)(<span style="color: #9370db;">char</span> *))
{
  <span style="color: #9370db;">char</span> <span style="color: #9acd32;">name</span>[MAX_PATH];
  <span style="color: #9370db;">Dirent</span> *<span style="color: #9acd32;">dp</span>;                   <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">directory pointer </span><span style="color: #cd853f;">*/</span>
  <span style="color: #9370db;">DIR</span> *<span style="color: #9acd32;">dfd</span>;



  <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">try to open, if success, continue, or return if fail </span><span style="color: #cd853f;">*/</span>
  <span style="color: #20b2aa; font-weight: bold;">if</span> ((dfd = opendir(dir)) == <span style="color: #1e90ff;">NULL</span>) { 
    fprintf(stderr, <span style="color: #ffa07a;">"dirwalk: can't open %s\n"</span>, dir);
    <span style="color: #20b2aa; font-weight: bold;">return</span>;
  }

  <span style="color: #20b2aa; font-weight: bold;">while</span> ((dp = readdir(dfd)) != <span style="color: #1e90ff;">NULL</span>) {
    <span style="color: #20b2aa; font-weight: bold;">if</span> (strcmp(dp-&gt;name, <span style="color: #ffa07a;">"."</span>) == 0 || strcmp(dp-&gt;name, <span style="color: #ffa07a;">".."</span>))
      <span style="color: #20b2aa; font-weight: bold;">continue</span>;                 <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">skip self and parent </span><span style="color: #cd853f;">*/</span>

    <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">dirrectory length + filename length + two '\0' </span><span style="color: #cd853f;">*/</span>
    <span style="color: #20b2aa; font-weight: bold;">if</span> (strlen(dir) + strlen(dp-&gt;name) + 2 &gt; <span style="color: #20b2aa; font-weight: bold;">sizeof</span>(name))
      fprintf(stderr, <span style="color: #ffa07a;">"dirwalk: name %s %s too long\n"</span>, dir, dir-&gt;name);
    <span style="color: #20b2aa; font-weight: bold;">else</span> {
      sprintf(name, <span style="color: #ffa07a;">"%s/%s"</span>, dir, dp-&gt;name);
      (*fcn)(name);
    }
  }
  closedir(fdf);
}

</pre>
</div>

<p>
dir.c:<br />
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #cd853f;">/* </span><span style="color: #cd853f;">Version &amp; and System V UNIX </span><span style="color: #cd853f;">*/</span>
<span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>

<span style="color: #6495ed;">#if</span><span style="color: #6495ed;">n</span><span style="color: #6495ed;">def</span> DIRSIZ
<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">DIRSIZ</span> 14
<span style="color: #6495ed;">#endif</span>

<span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">direct</span> {                 <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">directory entry </span><span style="color: #cd853f;">*/</span>
    <span style="color: #9370db;">ino_t</span> <span style="color: #9acd32;">d_ino</span>;                        <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">inode number </span><span style="color: #cd853f;">*/</span>
    <span style="color: #9370db;">char</span> <span style="color: #9acd32;">d_name</span>[DIRSIZ];                <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">long name does not have '\0' </span><span style="color: #cd853f;">*/</span>
};

<span style="color: #9370db;">int</span> <span style="color: #00ff7f;">fstat</span>(<span style="color: #9370db;">int</span> <span style="color: #9acd32;">fd</span>, <span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">stat</span> *);

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">opendir: open a directory for readdir calls </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">DIR</span> *<span style="color: #00ff7f;">opendir</span>(<span style="color: #9370db;">char</span> *<span style="color: #9acd32;">dirname</span>)
{
    <span style="color: #9370db;">int</span> <span style="color: #9acd32;">fd</span>;
    strcut <span style="color: #9370db;">stat</span> <span style="color: #9acd32;">stbuf</span>;
    <span style="color: #9370db;">DIR</span> *<span style="color: #9acd32;">dp</span>;

    <span style="color: #20b2aa; font-weight: bold;">if</span> ((fd = open(dirname, O_RDONLY, 0)) == -1 || <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">can read </span><span style="color: #cd853f;">*/</span>
        fstat(fd, &amp;stbuf) == -1 ||
        (stbuf.st_mode &amp; S_IFMT) != S_IFDIR || <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">directory </span><span style="color: #cd853f;">*/</span>
        (dp = (<span style="color: #9370db;">DIR</span> *) malloc(<span style="color: #20b2aa; font-weight: bold;">sizeof</span>(DIR))) == <span style="color: #1e90ff;">NULL</span>) <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">enought storage to allocate </span><span style="color: #cd853f;">*/</span>
        <span style="color: #20b2aa; font-weight: bold;">return</span> <span style="color: #1e90ff;">NULL</span>;

    dp-&gt;fd = fd;
    <span style="color: #20b2aa; font-weight: bold;">return</span> dp;
}

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">closedir: close directory opened by opendir  </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">void</span> <span style="color: #00ff7f;">closedir</span>(<span style="color: #9370db;">DIR</span> *<span style="color: #9acd32;">dp</span>)
{
    <span style="color: #20b2aa; font-weight: bold;">if</span> (dp) {
        close(dp-&gt;fd);
        free(dp);
    }
}

<span style="color: #6495ed;">#include</span> <span style="color: #ffa07a;">&lt;sys/dir.h&gt;</span>            <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">local directory structure </span><span style="color: #cd853f;">*/</span>

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">readdir: read directory entries in sequence </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">Dirent</span> *<span style="color: #00ff7f;">readdir</span>(<span style="color: #9370db;">DIR</span> *<span style="color: #9acd32;">dp</span>)
{
    <span style="color: #20b2aa; font-weight: bold;">struct</span> <span style="color: #9370db;">direct</span> <span style="color: #9acd32;">dirbuf</span>;       <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">local directory structure </span><span style="color: #cd853f;">*/</span>
    <span style="color: #20b2aa; font-weight: bold;">static</span> <span style="color: #9370db;">Dirent</span> <span style="color: #9acd32;">d</span>;            <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">return: portable structure </span><span style="color: #cd853f;">*/</span>

    <span style="color: #20b2aa; font-weight: bold;">while</span> (read(dp-&gt;fd, (<span style="color: #9370db;">char</span> *) &amp;dirbuf, <span style="color: #20b2aa; font-weight: bold;">sizeof</span>(dirbuf)) == <span style="color: #20b2aa; font-weight: bold;">sizeof</span>(dirbuf)) {
        <span style="color: #20b2aa; font-weight: bold;">if</span> (dirbuf.d_ino == 0)  <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">slot not in use, the file has been deleted </span><span style="color: #cd853f;">*/</span>
            <span style="color: #20b2aa; font-weight: bold;">continue</span>;

        d.ino = dirbuf.d_ino;
        strncpy(d.name, dirbuf.d_name, DIRSIZ);
        d.name[DIRSIZ] = <span style="color: #ffa07a;">'\0'</span>;  <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">ensure termination </span><span style="color: #cd853f;">*/</span>
        <span style="color: #20b2aa; font-weight: bold;">return</span> &amp;d;
    }
    <span style="color: #20b2aa; font-weight: bold;">return</span> <span style="color: #1e90ff;">NULL</span>;
}

</pre>
</div>
</div>
</div>

<div id="outline-container-org90baca5" class="outline-3">
<h3 id="org90baca5"><span class="section-number-3">8.7</span> Example - A Storage Allocator</h3>
<div class="outline-text-3" id="text-8-7">
<p>
Rather than allocating from a compiled-in fixed-size array, <code>malloc</code> will request space from the operating system as needed. Since othe activities in the program may also request space without calling this allocator, the space that <code>malloc</code> manages may not be contiguous. Thus its free storage is kept as a list of free blocks. Each block contains a size, a pointer to the next block, and the space itself. The blocks are kept in order of increasing storage address, and the last block (hightest address) points to the first.<br />
</p>


<div class="figure">
<p><img src="pics/malloc.png" alt="malloc.png" /><br />
</p>
</div>

<p>
When a request is made, the free list is scanned until a big-enough block is found. This algorithm is called ``first fit,'' by contrast with ``best fit,'' which looks for the smallest block that will satisfy the request. If the block is exactly the size requested it is unlinked from the list and returned to the user. If the block is too big, it is split, and the proper amount is returned to the user while the residue remains on the free list. If no big-enough block is found, another large chunk is obtained by the operating system and linked into the free list.<br />
</p>


<p>
Freeing also causes a search of the free list, to find the proper place to insert the block being freed. If the block being freed is adjacent to a free block on either side, it is coalesced with it into a single bigger block, so storage does not become too fragmented. Determining the adjacency is easy because the free list is maintained in order of decreasing address.<br />
</p>




<div class="figure">
<p><img src="pics/malloc2.png" alt="malloc2.png" /><br />
</p>
</div>

<p>
A free block contains a pointer to the next block in the chain, a record of the size of the block, and then the free space itself; the control information at the beginning is called the ``header.'' To simplify alignment, all blocks are multiples of the header size, and the header is aligned properly. This is achieved by a union that contains the desired header structure and an instance of the most restrictive alignment type.<br />
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">typedef</span> <span style="color: #9370db;">long</span> <span style="color: #9370db;">Align</span>;             <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">for alignment to long boundary </span><span style="color: #cd853f;">*/</span>

<span style="color: #20b2aa; font-weight: bold;">union</span> <span style="color: #9370db;">header</span> {
  <span style="color: #20b2aa; font-weight: bold;">struct</span> {
    <span style="color: #20b2aa; font-weight: bold;">union</span> <span style="color: #9370db;">header</span> *<span style="color: #9acd32;">ptr</span>;          <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">next block if on free list </span><span style="color: #cd853f;">*/</span>
    <span style="color: #9370db;">unsigned</span> <span style="color: #9acd32;">size</span>;              <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">size of this block </span><span style="color: #cd853f;">*/</span>
  } <span style="color: #9acd32;">s</span>;
  <span style="color: #9370db;">Align</span> <span style="color: #9acd32;">x</span>;                      <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">force alignment of blocks </span><span style="color: #cd853f;">*/</span>
};                              
<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">The Align filed is never used; it just forces each header to be aligned on a worst-case boundary. </span><span style="color: #cd853f;">*/</span>
</pre>
</div>


<p>
The variable <code>base</code> is used to get started. If <code>freep</code> is NULL, as it is at the first call of <code>malloc</code>, then a degenerate free list is created; it constains one block of size zero, and pointers to itself. In any case, the free list is then searched. The search for a free block of adequate size begins at the point (<code>freep</code>) where the last block was found; this strategy helps keep the list homogeneous. If a too-big block is found, the tail end is returned to the user; in this way the header of the original needs only to have size adjusted. In all cases, the pointer returned to the user points to the free space within the block, which begins one unit beyond the header.<br />
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #20b2aa; font-weight: bold;">static</span> <span style="color: #9370db;">Header</span> <span style="color: #9acd32;">base</span>;             <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">empty list to get started </span><span style="color: #cd853f;">*/</span>
<span style="color: #20b2aa; font-weight: bold;">static</span> <span style="color: #9370db;">Header</span> *<span style="color: #9acd32;">freep</span> = <span style="color: #1e90ff;">NULL</span>;    <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">start of free list </span><span style="color: #cd853f;">*/</span>

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">malloc: general-purpose storage allocator </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">void</span> *<span style="color: #00ff7f;">malloc</span>(<span style="color: #9370db;">unsigned</span> <span style="color: #9acd32;">nbytes</span>)
{
  <span style="color: #9370db;">Header</span> *<span style="color: #9acd32;">p</span>, *<span style="color: #9acd32;">prevp</span>;
  <span style="color: #9370db;">Header</span> *<span style="color: #00ff7f;">morecore</span>(<span style="color: #9370db;">unsigned</span>);   <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">obtains storeage from the operating system </span><span style="color: #cd853f;">*/</span>
  <span style="color: #9370db;">unsigned</span> <span style="color: #9acd32;">nunits</span>;

  nunits = (nbytes + <span style="color: #20b2aa; font-weight: bold;">sizeof</span>(Header) - 1) / <span style="color: #20b2aa; font-weight: bold;">sizeof</span>(header) + 1;
  <span style="color: #20b2aa; font-weight: bold;">if</span> ((prevp == freep) == <span style="color: #1e90ff;">NULL</span>) { <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">no free list yet </span><span style="color: #cd853f;">*/</span>
      base.s.ptr = freeptr = prevptr = &amp;base;
      base.s.size = 0;
  }

  <span style="color: #20b2aa; font-weight: bold;">for</span> (p = prevp-&gt;s.ptr; ; prevp = p, p = p-&gt;s.ptr) { <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">search </span><span style="color: #cd853f;">*/</span>
      <span style="color: #20b2aa; font-weight: bold;">if</span> (p-&gt;s.size &gt;= nunits) {                      <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">big enough </span><span style="color: #cd853f;">*/</span>
          <span style="color: #20b2aa; font-weight: bold;">if</span> (p-&gt;s.size == nunits)                    <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">exactly equal </span><span style="color: #cd853f;">*/</span>
              prevp-&gt;s.ptr = p-&gt;s.ptr;
          <span style="color: #20b2aa; font-weight: bold;">else</span> {                <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">allocate tail end </span><span style="color: #cd853f;">*/</span>
              p-&gt;s.size -= nunits; <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">nunits has be allocated, so the free block size decrease </span><span style="color: #cd853f;">*/</span>
              p += p-&gt;s.size;      <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">tail end pointer </span><span style="color: #cd853f;">*/</span>
              p-&gt;s.size = nunits;  <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">allocated size </span><span style="color: #cd853f;">*/</span>
          }

          freep = prevp;        <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">free from this position (allocated by malloc) </span><span style="color: #cd853f;">*/</span>
          <span style="color: #20b2aa; font-weight: bold;">return</span> (<span style="color: #9370db;">void</span> *) (p+1);
      }

      <span style="color: #20b2aa; font-weight: bold;">if</span> (p == freep)           <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">wrapped around free list </span><span style="color: #cd853f;">*/</span>
          <span style="color: #20b2aa; font-weight: bold;">if</span> ((p = morecore(nunits)) == <span style="color: #1e90ff;">NULL</span>)
              <span style="color: #20b2aa; font-weight: bold;">return</span> <span style="color: #1e90ff;">NULL</span>;      <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">none left </span><span style="color: #cd853f;">*/</span>
  }
}


<span style="color: #6495ed;">#define</span> <span style="color: #9acd32;">NALLOC</span> 1024             <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">minimum #units to request </span><span style="color: #cd853f;">*/</span>

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">morecore: ask system for more memory </span><span style="color: #cd853f;">*/</span>
<span style="color: #20b2aa; font-weight: bold;">static</span> <span style="color: #9370db;">Header</span> *<span style="color: #00ff7f;">morecore</span>(<span style="color: #9370db;">unsigned</span> <span style="color: #9acd32;">nu</span>)
{
    <span style="color: #9370db;">char</span> *<span style="color: #9acd32;">cp</span>, *<span style="color: #00ff7f;">sbrk</span>(<span style="color: #9370db;">int</span>);
    <span style="color: #9370db;">Header</span> *<span style="color: #9acd32;">up</span>;

    <span style="color: #20b2aa; font-weight: bold;">if</span> (nu &lt; NALLOC)
        nu = NALLOC;

    <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">The UNIX system call sbrk(n) returns a pointer to n more bytes of storage.</span>
<span style="color: #cd853f;">     * sbrk returns -1 if there was no space, even though NULL could have been a better design.</span>
<span style="color: #cd853f;">     * The -1 must be cast to char * so it can be compared with the return value.  </span><span style="color: #cd853f;">*/</span>
    cp = sbrk(<span style="color: #9370db;">nu</span> * <span style="color: #20b2aa; font-weight: bold;">sizeof</span>(Header)); <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">request how may memory </span><span style="color: #cd853f;">*/</span>
    <span style="color: #20b2aa; font-weight: bold;">if</span> (cp == (<span style="color: #9370db;">char</span> *) -1)          <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">no space at all </span><span style="color: #cd853f;">*/</span>
        <span style="color: #20b2aa; font-weight: bold;">return</span> <span style="color: #1e90ff;">NULL</span>;

    up = (<span style="color: #9370db;">Header</span> *) cp;
    up-&gt;s.size = nu;

    free((<span style="color: #9370db;">void</span> *) (up+1));
    <span style="color: #20b2aa; font-weight: bold;">return</span> freep;
}

<span style="color: #cd853f;">/* </span><span style="color: #cd853f;">free: put block ap in free list </span><span style="color: #cd853f;">*/</span>
<span style="color: #9370db;">void</span> <span style="color: #00ff7f;">free</span>(<span style="color: #9370db;">void</span> *<span style="color: #9acd32;">ap</span>)
{
    <span style="color: #9370db;">Header</span> *<span style="color: #9acd32;">bp</span>, *<span style="color: #9acd32;">p</span>;

    bp = (<span style="color: #9370db;">Header</span> *) ap - 1;     <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">point to block header </span><span style="color: #cd853f;">*/</span>
    <span style="color: #20b2aa; font-weight: bold;">for</span> (p = freep; !(bp &gt; p &amp;&amp; bp &lt; p-&gt;s.ptr); p = p-&gt;s.ptr)
        <span style="color: #20b2aa; font-weight: bold;">if</span> (p &gt;= p-&gt;s.ptr &amp;&amp; (bp &gt; p || bp &lt; p-&gt;s.ptr))
            <span style="color: #20b2aa; font-weight: bold;">break</span>;              <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">freed block at start or end of arena </span><span style="color: #cd853f;">*/</span>

    <span style="color: #20b2aa; font-weight: bold;">if</span> (bp + bp-&gt;size == p-&gt;s.ptr) { <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">join to upper neighbor </span><span style="color: #cd853f;">*/</span>
        bp-&gt;s.size += p-&gt;s.ptr-&gt;s.size;
        bp-&gt;s.ptr = p-&gt;s.ptr-&gt;s.ptr;
    } <span style="color: #20b2aa; font-weight: bold;">else</span>
        bp-&gt;s.ptr = p-&gt;s.ptr;

    <span style="color: #20b2aa; font-weight: bold;">if</span> (p + p-&gt;size == bp) {    <span style="color: #cd853f;">/* </span><span style="color: #cd853f;">join to lower neighbor </span><span style="color: #cd853f;">*/</span>
        p-&gt;s.size += bp-&gt;s.size;
        p-&gt;s.ptr = bp-&gt;s.ptr;
    } <span style="color: #20b2aa; font-weight: bold;">else</span>
        p-&gt;s.ptr = bp;

    freep = p;
}

</pre>
</div>




<p>
Hint:<br />
Although storage allocation is intrinsically machine-dependent, the code above illustrates how the machine dependencies can be controlled and confined to a very small part of the program. The use of typedef and union handles alignment (given that sbrk supplies an appropriate pointer). Casts arrange that pointer conversions are made explicit, and even cope with a badly- designed system interface. Even though the details here are related to storage allocation, the general approach is applicable to other situations as well.<br />
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Mike Chyson</p>
<p class="date">Created: 2020-05-03 Sun 21:37</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
