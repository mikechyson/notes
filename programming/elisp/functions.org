* +
* <
* append-to-buffer
Most of append-to-buffer is concerted with setting up the conditions for insert-buffer-substring.
#+BEGIN_SRC emacs-lisp
(defun append-to-buffer (buffer start end)
  "Documentation"
  (interactive
   (list (read-buffer "Append to buffer"
		      (other-buffer (current-buffer) t))
	 (region-beginning)
	 (region-end)))
  (let ((oldbuf (current-buffer)))
    (save-excursion
      (let* ((apend-to (get-buffer-create buffer))
	     (windows (get-buffer-window-list appen-to t t)) ;the first t is include the nimibufer
					;the second t is consider all windows on all existing frames
	     point)
	(set-buffer append-to)
	(setq point (point))
	(barf-if-buffer-read-only) 	; an assert
	(insert-buffer-substring oldbuf start end)
	(dolist (window windows)
	  (when (= (window-point window) point)
	    (set-window-point window (point))))))))
#+END_SRC
* aref
(aref ARRAY IDX)

array reference.

Return the element of ARRAY at index IDX.

* barf-if-buffer-read-only

* beginning-of-buffer
#+BEGIN_SRC emacs-lisp
(defun simplified-beginning-of-buffer ()
  "Move point to the beginning of the buffer;
leave mark at previous position."
  (interactive)
  (push-mark)
  (goto-char (point-min)))
#+END_SRC


complete explaination:
(beginning-of-buffer &optional ARG)

This function is for interactive use only;
in Lisp code use `(goto-char (point-min))' instead.

Move point to the beginning of the buffer.
With numeric arg N, put point N/10 of the way from the beginning.


#+BEGIN_SRC python
(defun beginning-of-buffer (&optinal arg)
  "Move point to the beginning of the buffer;
leave mark at the previous position.
With \\[universial-argument] prefix,
do not set mark at previous position.
With numberic arg N,
put point N/10 of the way from the beginning.

If the buffer is narrowed,
this command uses the beginning and size
of the accessible part of the buffer.

Don't use this command in Lisp program!
\(goto-char (point-min)) is faster
and avoids clobbering the mark."
  (interactive "P")
  (or (consp arg)			;is the argument is a cons cell arg (that is C-u prefix without N)
      (and transient-mark-mode mark-active) ;in narrowing and the region is active
      (push-mark))			    ;record current point as mark
  (let ((size (- (point-max) (point-min)))) ;buffer size
    (goto-char (if (and arg (not (consp arg))) ;N prefix
		   (+ (point-min)
		      (if (> size 10000) ;avoid overflow for large buffer sizes!
					;divide 10 first
			  (* (prefix-number-value arg)
			     (/ size 10))
			(/ (+ 10 (* size (prefix-number-value arg)))
			   10)))
		 (point-min))))		;no N prefix
		 (if (and arg (not (consp arg)))	;N prefix
      (forward-line 1)))		;make sure the cursor is at the beginning of the next line of the point
		 
  
  
#+END_SRC
* beginning-of-line

* buffer-file-name
the name of the file to which the buffer refers appears in the echo area. (fullpath)
* buffer-name
the name of the buffer appears in the echo area.
* buffer-size
* bufferp

* car
The first item in the list.
car does not remove the first item from the list; it only reports what it is.
car is "non-desctructive".

* cdr
The rest of the list, that is the part of the list that follows the first item.
cdr does not remove any elements from the list.
cdr is "non-desctructive"

* char-table-p
(char-table-p OBJECT)

Return t if OBJECT is a char-table.

* concat
concaternate
* condition-case
Like try...catch

Template:
#+BEGIN_SRC emacs-lisp
(condition-case
    var
    bodyform 
    error-handler...)
#+END_SRC

The bodyform part of a condition-case expression determines what should happen when everything works correctly.

An error handler has two parts, a condition-name and a body. 
If the condition-name part of an error handler matches a condition name generated by an error, then the body part of the error handler is run.

The var argument, is sometimes bound to a variable that contains information about the error. 
However, if that argument is nil that information is discarded.
* cons
construct lists.
cons does not change an existing list, but creates a new one.

cons must have list to attach to.

* consp

* copy-to-buffer
Copy to specified buffer the text of the region.

#+BEGIN_SRC emacs-lisp
(defun copy-to-buffer (buffer start end)
  "..."
  (interactive "BCopy to buffer: \nr")
  (let ((oldbuf (current-buffer)))
    (with-current-buffer (get-buffer-create buffer)
      (barf-if-buffer-read-only)
      (erase-buffer)
      (save-excursion
	(insert-buffer-substring oldbuf start end)))))
#+END_SRC

* count-lines

* current-buffer
Return the current buffer as a Lisp object.

(current-buffer) ; #<buffer functions.org>
* descirbe-function
C-h f
* describe-variable
C-h v
* dolist
(dolist (VAR LIST [RESULT]) BODY...)

Loop over a list.

* end-of-buffer
#+BEGIN_SRC emacs-lisp
(defun simplified-end-of-buffer ()
  "Move point to the end of the buffer;
leave mark at previous position."
  (interactive)
  (push-mark)
  (goto-char (point-max)))
#+END_SRC
* erase-buffer
Delete the entire contents of the current buffer.

* eval-last-sexp 
evaluate last symbolic expression
bound to C-x C-e
with C-u prefix, it insert the output in current buffer instead of in echo area.
* format
| %s | string                           |
| %d | signed number in decimal         |
| %o | unsigned number in octal         |
| %x | unsigned number in hex           |
| %e | number in exponential notation   |
| %f | number in decimal-point notation |
| %g |                                  |
| %c | a single character               |
| %S | any object as an S-expression    |
   
* forward-char
bound to C-f
* forward-sentence
bound to M-e
* get-buffer-create
(get-buffer-create BUFFER-OR-NAME)

Return the buffer specified by BUFFER-OR-NAME, creating a new one if needed.
* get-buffer-window-list
(get-buffer-window-list &optional BUFFER-OR-NAME MINIBUF ALL-FRAMES)

Return list of all windows displaying BUFFER-OR-NAME, or nil if none.

* if
The basic idea behind an if, is that, "if a test is true, then an expression is evaluated;
if the test is not true, the expression is not evaluated."

#+BEGIN_SRC emacs-lisp
;; simple template
(if true-or-false-test
    action-to-carry-out-if-test-returns-true)

;; complex template
(if true-or-false-test
    action-to-carry-out-if-test-returns-true
  action-to-carry-out-if-test-returns-false)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun type-of-animal (characteristic)
  "Print message in echo area depending on CHARACTERISTIC.
If the CHARACTERISTIC is the string \"fierce\",
then warn of a tiger; else say it is not fierce."
  (if (equal characteristic "fierce")
      (message "It is a tiger!")
    (message "It is not fierce")))

(type-of-animal "fierce") 		; "It is a tiger!"
(type-of-animal "striped")		; "It is not fierce"
#+END_SRC


* insert-buffer
#+BEGIN_SRC emacs-lisp
(defun insert-buffer (buffer)
  "Insert after point the contents of BUFFER."
  ;; The asterisk is for the situation when the current buffer is
  ;; read-only
  ;; when the current buffer is read-only, a message to this effect
  ;; is printed in the echo area and the terminal may beep or blink at you
  ;; The asterisk does not need to be followed by a newline to
  ;; separate it from the next argument.
  (interactive "*bInsert buffer: ")
  (or (bufferp buffer)
      (setq buffer (get-buffer-create buffer)))
  (let (start end newmark)
    (save-excursion
      (save-excursion
	(set-buffer buffer)
	(setq start (point-min) end (point-max)))
      (insert-buffer-substring buffer start end)
      (setq newmark (point)))
    (push-mark newmark)))
#+END_SRC

* insert-buffer-substring
(insert-buffer-substring BUFFER &optional START END)

Insert before point a substring of the contents of BUFFER.
* interactive
Specify a way of parsing arguments for interactive use of a function.
| Code Letter | Meaning                                                                                 |
|-------------+-----------------------------------------------------------------------------------------|
| P           | Prefix arg in raw form                                                                  |
| p           | Prefix arg converted to number.  If called interactively without a prefix, 1 is passed. |
|-------------+-----------------------------------------------------------------------------------------|
| B           | Name of buffer, possibly nonexistent                                                    |
| b           | Name of existing buffer                                                                 |
| c           | Character                                                                               |
| f           | Name of existing file                                                                   |
| r           | Region: point and mark as 2 numeric args, smallest first                                |
|             |                                                                                         |

Emacs has more than twenty characters predefined for use with interactive.
In almost every case, one of these options will enable you to pass the right information interactively to a funkction.

A function with two or more arguments can have information passed to each argument by adding parts to the string that follows interactive.
The information is passed to each argument in the same order it is specified in the interactive list.
In the string, each part is separated from the next part by a '\n'.

#+BEGIN_SRC emacs-lisp
(defun name-of-function (arg char)
  "documentation..."
  (interactive "p\ncZap to char: ")
  body-of-function...)
#+END_SRC
arg and char are the symbols to which interactive binds the prefix argument and the specified character.


* kill-append
(kill-append STRING BEFORE-P)

Append STRING to the end of the latest kill in the kill ring.
If BEFORE-P is non-nil, prepend STRING to the kill instead.

#+BEGIN_SRC emacs-lisp

(defun kill-append (string before-p)
  "Append STRING to the end of the latest kill in the kill ring.
If BEFORE-P is non-nil, prepend STRING to the kill instead.
If `interprogram-cut-function' is non-nil, call it with the
resulting kill.
If `kill-append-merge-undo' is non-nil, remove the last undo
boundary in the current buffer."
  (let* ((cur (car kill-ring)))
    (kill-new (if before-p (concat string cur) (concat cur string))
	      (or (= (length cur) 0)
		  (equal nil (get-text-property 0 'yank-handler cur))))
    (when (and kill-append-merge-undo (not buffer-read-only))
      (let ((prev buffer-undo-list)
            (next (cdr buffer-undo-list)))
        ;; find the next undo boundary
        (while (car next)
          (pop next)
          (pop prev))
        ;; remove this undo boundary
        (when prev
          (setcdr prev (cdr next)))))))

#+END_SRC

* kill-new

(kill-new STRING &optional REPLACE)

Make STRING the latest kill in the kill ring.

#+BEGIN_SRC emacs-lisp

(defun kill-new (string &optional replace)
  "Make STRING the latest kill in the kill ring.
Set `kill-ring-yank-pointer' to point to it.
If `interprogram-cut-function' is non-nil, apply it to STRING.
Optional second argument REPLACE non-nil means that STRING will replace
the front of the kill ring, rather than being added to the list.

When `save-interprogram-paste-before-kill' and `interprogram-paste-function'
are non-nil, save the interprogram paste string(s) into `kill-ring' before
STRING.

When the yank handler has a non-nil PARAM element, the original STRING
argument is not used by `insert-for-yank'.  However, since Lisp code
may access and use elements from the kill ring directly, the STRING
argument should still be a \"useful\" string for such uses."
  (unless (and kill-do-not-save-duplicates
	       ;; Due to text properties such as 'yank-handler that
	       ;; can alter the contents to yank, comparison using
	       ;; `equal' is unsafe.
	       (equal-including-properties string (car kill-ring)))
    (if (fboundp 'menu-bar-update-yank-menu)
	(menu-bar-update-yank-menu string (and replace (car kill-ring)))))
  (when save-interprogram-paste-before-kill
    (let ((interprogram-paste (and interprogram-paste-function
                                   (funcall interprogram-paste-function))))
      (when interprogram-paste
        (dolist (s (if (listp interprogram-paste)
		       (nreverse interprogram-paste)
		     (list interprogram-paste)))
	  (unless (and kill-do-not-save-duplicates
		       (equal-including-properties s (car kill-ring)))
	    (push s kill-ring))))))
  (unless (and kill-do-not-save-duplicates
	       (equal-including-properties string (car kill-ring)))
    (if (and replace kill-ring)
	(setcar kill-ring string)
      (push string kill-ring)
      (if (> (length kill-ring) kill-ring-max)
	  (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))))
  (setq kill-ring-yank-pointer kill-ring)
  (if interprogram-cut-function
      (funcall interprogram-cut-function string)))
#+END_SRC
* kill-region
(kill-region BEG END &optional REGION)

Kill ("cut") text between point and mark.

#+BEGIN_SRC emacs-lisp

(defun kill-region (beg end &optional region)
  "Kill (\"cut\") text between point and mark.
This deletes the text from the buffer and saves it in the kill ring.
The command \\[yank] can retrieve it from there.
\(If you want to save the region without killing it, use \\[kill-ring-save].)

If you want to append the killed region to the last killed text,
use \\[append-next-kill] before \\[kill-region].

Any command that calls this function is a \"kill command\".
If the previous command was also a kill command,
the text killed this time appends to the text killed last time
to make one entry in the kill ring.

The killed text is filtered by `filter-buffer-substring' before it is
saved in the kill ring, so the actual saved text might be different
from what was killed.

If the buffer is read-only, Emacs will beep and refrain from deleting
the text, but put the text in the kill ring anyway.  This means that
you can use the killing commands to copy text from a read-only buffer.

Lisp programs should use this function for killing text.
 (To delete text, use `delete-region'.)
Supply two arguments, character positions BEG and END indicating the
 stretch of text to be killed.  If the optional argument REGION is
 non-nil, the function ignores BEG and END, and kills the current
 region instead."
  ;; Pass mark first, then point, because the order matters when
  ;; calling `kill-append'.
  (interactive (list (mark) (point) 'region))
  (unless (and beg end)
    (user-error "The mark is not set now, so there is no region"))
  (condition-case nil
      (let ((string (if region
                        (funcall region-extract-function 'delete)
                      (filter-buffer-substring beg end 'delete))))
	(when string			;STRING is nil if BEG = END
	  ;; Add that string to the kill ring, one way or another.
	  (if (eq last-command 'kill-region)
	      (kill-append string (< end beg))
	    (kill-new string)))
	(when (or string (eq last-command 'kill-region))
	  (setq this-command 'kill-region))
	(setq deactivate-mark t)
	nil)
    ((buffer-read-only text-read-only)
     ;; The code above failed because the buffer, or some of the characters
     ;; in the region, are read-only.
     ;; We should beep, in case the user just isn't aware of this.
     ;; However, there's no harm in putting
     ;; the region's text in the kill ring, anyway.
     (copy-region-as-kill beg end region)
     ;; Set this-command now, so it will be set even if we get an error.
     (setq this-command 'kill-region)
     ;; This should barf, if appropriate, and give us the correct error.
     (if kill-read-only-ok
	 (progn (message "Read only text copied to kill ring") nil)
       ;; Signal an error if the buffer is read-only.
       (barf-if-buffer-read-only)
       ;; If the buffer isn't read-only, the text is.
       (signal 'text-read-only (list (current-buffer)))))))

#+END_SRC


* length
(length SEQUENCE)

Return the length of vector, list or string SEQUENCE.
#+BEGIN_SRC emacs-lisp
(length '(a b)) ; 2
#+END_SRC

* let
to bind a symbol to a value locally.

let creates a name for a local variable that overshadow any use of the same name outside the let expression.
(Symbols used in argument list work the same way.)

#+BEGIN_SRC emacs-lisp
;; simple template
(let varlist body...)

;; complex template
(let ((variable value)
      (variable value)
      ...)
  body...)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(let ((birch 3)
      pine
      fir
      (oak 'some))
  (message
   "Here are %d variable with %s, %s, and %s value."
   birch pine fir oak))
;; "Here are 3 variable with nil, nil, and some value."
#+END_SRC
If you do not bind the variable in a let statement to specific initial values,
they will automatically be bound to an inital value of nil.

* let*
(let* VARLIST BODY...)

Bind variables according to VARLIST then eval BODY.
The value of the last form in BODY is returned.
Each element of VARLIST is a symbol (which is bound to nil)
or a list (SYMBOL VALUEFORM) (which binds SYMBOL to the value of VALUEFORM).
Each VALUEFORM can refer to the symbols already bound by this VARLIST.



* list
Return a newly created list with specified arguments as elements.

* listp
* mark-whole-buffer
C-x h
#+BEGIN_SRC python
(defun mark-whole-buffer ()
  "Put point at beginning and mark at end of buffer.
You probably should not use this function in Lisp programs;
it is usually a mistake for a Lisp function to use any subroutine
that uses or sets the mark."
  (interactive)
  (push-mark)
  (push-mark (point-max) nil t)
  (goto-char (point-min)))
#+END_SRC
* message
A message is printed in the echo area.
[2019-03-21 Thu]
* not

* nth
(nth N LIST)

Return the Nth element of LIST.
N counts from zero.  If LIST is not that long, nil is returned.

"non-desctructive"

* nthcdr
(nthcdr N LIST)

Take cdr N times on LIST, return the result.

"non-desctructive"

* number-or-marker-p
number or marker predict
a predict prefers to a function to determine whether some property is true of false.
* number-to-string
* or
(or CONDITIONS...)

Eval args until one of them yields non-nil, then return that value.
The remaining args are not evalled at all.
If all args return nil, return nil.

* other-buffer

(other-buffer &optional BUFFER VISIBLE-OK FRAME)

Return most recently selected buffer other than BUFFER.

* point
the current position of the cursor is called point.
The expression (point) returns a number the tells where the cursor is 
located as a count of the number of characters from the beginning of the buffer to point.
* point-max
* point-min
* prefix-numeric-value
(prefix-numeric-value RAW)

Return numeric meaning of raw prefix argument RAW.
* progn
(progn BODY...)

Eval BODY forms sequentially and return value of last one.
The preceding expressions are evaluated only for the side effects they perform. The values produced by them are discarded.

* push-mark
(push-mark &optional LOCATION NOMSG ACTIVATE)

Set mark at LOCATION (point, by default) and push old mark on mark ring.
Display ‘Mark set’ unless the optional second arg NOMSG is non-nil.
In Transient Mark mode, activate mark if optional third arg ACTIVATE non-nil.
* quote
* read-buffer
Read the name of a buffer and return as a string.

(read-buffer PROMPT &optional DEF REQUIRE-MATCH PREDICATE)

Prompt with PROMPT.
Optional second arg DEF is value to return if user enters an empty line.

* read-char
(read-char &optional PROMPT INHERIT-INPUT-METHOD SECONDS)

Read a character from the command input (keyboard or macro).

* region-beginning
Return the integer value of point or mark, whichever is smaller.

* region-end
Return the integer value of point or mark, whichever is larger.

* save-excursion
It saves the location of point, executes the body of the function, and then restores point to its previous position if its location was changed.
Its primary purpose it ot keep the user from being surprised and disturbed by expected movement of point.

function:
1. save point and restore it
2. save buffer and restore it

template:
#+BEGIN_SRC emacs-lisp
(save-excursion
  body...)

(save-excursion
  first-expression-in-body
  second-expression-in-body
  third-expresion-in-body
  ...
  last-expression-in-body)
#+END_SRC

* save-restriction
When the Lisp interpreter meets with save-restriction, it executes the code in the body of 
the save-restriction expression, and then undoes any changes to narrowing that the code caused.

When you use both save-excursion and save-restriction, one right after the other, you should 
use save-excursion outermost.

#+BEGIN_SRC emacs-lisp
(save-excursion
  (save-restriction
    body...))
#+END_SRC

* search-forward
(search-forward STRING &optional BOUND NOERROR COUNT)

Search forward from point for STRING.
Set point to the end of the occurrence found, and return point.
* self-insert-command
simply inserts the character you typed.
* set
* set-buffer
designed for computers and does one things:
switch the attention of the computer program to a different buffer.
* set-mark-command
C-@
C-SPC


With prefix argument (e.g., C-u), jump to the mark, and set the mark from
position popped off the local mark ring (this does not affect the global
mark ring).



* setcar


* setcdr

* setq
set quote
* substring
* switch-to-buffer
bound to C-x b
switch-to-buffer is designed for humans and does two things:
1. switch the buffer to which Emacs's attention is directed
2. switch the buffer displayed in the window to the new buffer
* unless
(unless COND BODY...)

If COND yields nil, do BODY, else return nil.
* what-line
Print the current buffer line number and narrowed line number of point.

#+BEGIN_SRC emacs-lisp
(defun simplified-what-line ()
  "Document"
  (interactive)
  (save-restriction
    (widen)
    (save-excursion
      (beginning-of-line)
      (message "Line %d" (1+ (count-lines 1 (point)))))))
#+END_SRC

* when
(when COND BODY...)

If COND yields non-nil, do BODY, else return nil.

#+BEGIN_EXAMPLE
Note:
Different from the Python or Java.
It is not a loop function.

It is an if without the possibility of an else clause. 
In your mind, you can replace when with if and understand what goes on. 
That is what the Lisp interpreter does.
#+END_EXAMPLE

* widen

* with-current-buffer
#+BEGIN_SRC emacs-lisp
(with-current-buffer BUFFER-OR-NAME &rest BODY)

Execute the forms in BODY with BUFFER-OR-NAME temporarily current.
#+END_SRC

* with-no-warnings

* xref-find-definitions
Find the definition of the identifier at point.
* zap-to-char
It is bound to M-z.

(zap-to-char ARG CHAR)

Kill up to and including ARGth occurrence of CHAR.

#+BEGIN_SRC emacs-lisp
(defun zap-to-char (arg char)
  "Kill up to and including ARGth occurrence of CHAR.
Case is ignored if `case-fold-search' is non-nil in the current buffer.
Goes backward if ARG is negative; error if CHAR not found."
  (interactive (list (prefix-numeric-value current-prefix-arg) ;arg
		     (read-char "Zap to char: " t)))	       ;char
  ;; Avoid "obsolete" warnings for translation-table-for-input.
  (with-no-warnings
    (if (char-table-p translation-table-for-input)
	(setq char (or (aref translation-table-for-input char) char))))
  ;; The progn special form is necessary because the kill-region command takes two arguments; 
  ;; and it would fail if search-forward and point expressions were written in sequence as two additional arguments.
  (kill-region (point) (progn 
			 (search-forward (char-to-string char) nil nil arg)
			 (point))))

#+END_SRC

* zerop

* copy-region-as-kill

#+BEGIN_SRC emacs-lisp
(defun copy-region-as-kill (beg end &optional region)
  "Save the region as if killed, but don't kill it.
In Transient Mark mode, deactivate the mark.
If `interprogram-cut-function' is non-nil, also save the text for a window
system cut and paste.

The copied text is filtered by `filter-buffer-substring' before it is
saved in the kill ring, so the actual saved text might be different
from what was in the buffer.

When called from Lisp, save in the kill ring the stretch of text
between BEG and END, unless the optional argument REGION is
non-nil, in which case ignore BEG and END, and save the current
region instead.

This command's old key binding has been given to `kill-ring-save'."
  ;; Pass mark first, then point, because the order matters when
  ;; calling `kill-append'.
  (interactive (list (mark) (point)
		     (prefix-numeric-value current-prefix-arg)))
  (let ((str (if region
                 (funcall region-extract-function nil)
               (filter-buffer-substring beg end))))
  (if (eq last-command 'kill-region)
        (kill-append str (< end beg))
      (kill-new str)))
  (setq deactivate-mark t)  ; prevent the region from lighting up
  nil)

#+END_SRC

* transient-mark-mode
Toglle Transient Mark mode.

You can use Transient Mark mode to highlight a region temporarily.

* filter-buffer-substring
(filter-buffer-substring BEG END &optional DELETE)

Return the buffer substring between BEG and END, after filtering.
If DELETE is non-nil, delete the text between BEG and END from the buffer.


* equal
Return t if two Lisp objects have similar structure and contents.

* eq
Return t if the two args are the same Lisp object.

* defvar
(defvar SYMBOL &optional INITVALUE DOCSTRING)

Define SYMBOL as a variable, and return SYMBOL.

The defvar special form is similar to setq in that it sets the value of a variable. 
It is unlike setq in two ways: first, it only sets the value of the variable if the variable does not already have a value. 
If the variable already has a value, defvar does not override the existing value. 
Second, defvar has a documentation string.

* defcustom

* funcall
(funcall FUNCTION &rest ARGUMENTS)

Call first argument as a function, passing remaining arguments to it.

* delete-and-extract-region

(delete-and-extract-region START END)

Delete the text between START and END and return it.
